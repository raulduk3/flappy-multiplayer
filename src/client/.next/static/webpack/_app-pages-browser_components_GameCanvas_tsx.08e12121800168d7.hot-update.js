"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_components_GameCanvas_tsx",{

/***/ "(app-pages-browser)/./components/GameCanvas.tsx":
/*!***********************************!*\
  !*** ./components/GameCanvas.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GameCanvas; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_track__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/track */ \"(app-pages-browser)/./lib/track.ts\");\n/* harmony import */ var _lib_net__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/net */ \"(app-pages-browser)/./lib/net.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction GameCanvas(param) {\n    let { width, height } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [seed, setSeed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [tick, setTick] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [players, setPlayers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [localRunId, setLocalRunId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const cleanup = (0,_lib_net__WEBPACK_IMPORTED_MODULE_3__.connect)({\n            onOpen: ()=>setConnected(true),\n            onClose: ()=>setConnected(false),\n            onJoinAck: (payload)=>setSeed(payload.seed),\n            onSnapshot: (payload)=>{\n                setSeed(payload.seed);\n                setTick(payload.tick);\n                setPlayers(payload.players);\n            },\n            onRunStart: (payload)=>{\n                setLocalRunId(payload.run_id);\n            },\n            onRunEnd: ()=>{\n                // Reset local run so camera snaps back to start and doesn't follow others\n                setLocalRunId(null);\n            }\n        });\n        const onKey = (e)=>{\n            if (e.code === \"Space\") {\n                e.preventDefault();\n                window.dispatchEvent(new CustomEvent(\"flap\"));\n            }\n        };\n        window.addEventListener(\"keydown\", onKey);\n        const onTap = ()=>window.dispatchEvent(new CustomEvent(\"flap\"));\n        window.addEventListener(\"click\", onTap);\n        return ()=>{\n            window.removeEventListener(\"keydown\", onKey);\n            window.removeEventListener(\"click\", onTap);\n            cleanup === null || cleanup === void 0 ? void 0 : cleanup();\n        };\n    }, []);\n    // Derive the local player entity for the active run if known (by run_id)\n    const localPlayer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!localRunId) return undefined;\n        return players.find((p)=>p.run_id === localRunId);\n    }, [\n        players,\n        localRunId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let raf = 0;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));\n        // Resize backing store for crisp rendering\n        canvas.width = Math.floor(width * dpr);\n        canvas.height = Math.floor(height * dpr);\n        canvas.style.width = \"\".concat(width, \"px\");\n        canvas.style.height = \"\".concat(height, \"px\");\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        const render = ()=>{\n            ctx.clearRect(0, 0, width, height);\n            // Background\n            ctx.fillStyle = \"#0e1520\";\n            ctx.fillRect(0, 0, width, height);\n            // World scaling to match server-side WORLD_HEIGHT\n            const WORLD_H = 600;\n            const sY = height / WORLD_H;\n            // Camera: anchor only to local player's distance; otherwise stay at origin (don't follow others)\n            const LEAD_IN = 160; // pixels of space ahead of player on the left side\n            const camX = localPlayer ? localPlayer.distance : 0;\n            // Determine how many pipes to render so they fill the screen width\n            const spacingPx = (0,_lib_track__WEBPACK_IMPORTED_MODULE_2__.getPipeSpacingPx)();\n            const countAfter = Math.ceil((width + LEAD_IN) / spacingPx) + 2;\n            const countBefore = 3; // a bit more history so pipes don't drop too early\n            if (seed) {\n                const pipes = (0,_lib_track__WEBPACK_IMPORTED_MODULE_2__.getPipesAtTick)(seed, tick, {\n                    worldHeight: WORLD_H,\n                    countBefore,\n                    countAfter,\n                    baseDistance: camX\n                });\n                for (const p of pipes){\n                    const screenX = Math.round(LEAD_IN + (p.x - camX));\n                    // Cull if completely off screen (non-strict to avoid early pop)\n                    if (screenX + p.width <= 0 || screenX >= width) continue;\n                    const topH = (p.gapCenterY - p.gapHeight / 2) * sY;\n                    const botY = (p.gapCenterY + p.gapHeight / 2) * sY;\n                    ctx.fillStyle = \"#22c55e\";\n                    ctx.fillRect(screenX, 0, p.width, topH);\n                    ctx.fillRect(screenX, botY, p.width, height - botY);\n                }\n            }\n            // Draw players relative to camera\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"bottom\";\n            const labelPx = Math.max(10, Math.round(12 * (height / 600)));\n            ctx.font = \"\".concat(labelPx, \"px system-ui\");\n            for (const pl of players){\n                const x = Math.round(LEAD_IN + (pl.distance - camX));\n                const y = pl.position.y * (height / 600);\n                // Avatar\n                const isLocal = localPlayer && pl.run_id === localPlayer.run_id;\n                ctx.fillStyle = isLocal ? \"#fbbf24\" : \"#60a5fa\";\n                const aw = Math.max(16, Math.round(24 * (height / 600)));\n                const ah = Math.max(12, Math.round(18 * (height / 600)));\n                ctx.fillRect(x, y, aw, ah);\n                // Label above avatar\n                const label = (pl.player_id || \"?\").slice(0, 6);\n                ctx.fillStyle = \"#e5e7eb\";\n                ctx.fillText(label, x + Math.round(aw / 2), y - 4);\n            }\n            // If we don't yet have a local player from snapshots, render a placeholder\n            if (!localPlayer) {\n                const aw = Math.max(16, Math.round(24 * (height / 600)));\n                const ah = Math.max(12, Math.round(18 * (height / 600)));\n                const x = Math.round(LEAD_IN);\n                const y = Math.round(WORLD_H * 0.4 * sY);\n                ctx.fillStyle = \"#fbbf24\"; // highlight color for local placeholder\n                ctx.fillRect(x, y, aw, ah);\n                ctx.fillStyle = \"#e5e7eb\";\n                ctx.fillText(\"You\", x + Math.round(aw / 2), y - 4);\n            }\n            // HUD (render last to ensure it's on top)\n            const status = connected ? \"Connected\" : \"Connecting...\";\n            const hudLines = [\n                status\n            ];\n            const me = localPlayer;\n            if (me) {\n                const dist = Math.max(0, Math.floor(me.distance));\n                var _me_score;\n                const score = (_me_score = me.score) !== null && _me_score !== void 0 ? _me_score : 0;\n                hudLines.push(\"Score: \".concat(score));\n                hudLines.push(\"Dist: \".concat(dist, \"px\"));\n            }\n            const lineH = 18;\n            const pad = 8;\n            const hudW = 160;\n            const hudH = hudLines.length * lineH + pad * 2 - 4;\n            // backdrop for readability\n            ctx.fillStyle = \"rgba(2,6,23,0.6)\";\n            ctx.fillRect(8, 8, hudW, hudH);\n            ctx.fillStyle = \"#cbd5e1\";\n            ctx.font = \"14px system-ui\";\n            ctx.textBaseline = \"top\";\n            ctx.textAlign = \"left\";\n            let yOff = 8 + pad - 2;\n            for (const line of hudLines){\n                ctx.fillText(line, 12, yOff);\n                yOff += lineH;\n            }\n            raf = requestAnimationFrame(render);\n        };\n        raf = requestAnimationFrame(render);\n        return ()=>cancelAnimationFrame(raf);\n    }, [\n        width,\n        height,\n        seed,\n        tick,\n        players,\n        connected,\n        localRunId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: width,\n        height: height\n    }, void 0, false, {\n        fileName: \"/Users/richardalvarez/Dev/flappy-multiplayer/src/client/components/GameCanvas.tsx\",\n        lineNumber: 167,\n        columnNumber: 10\n    }, this);\n}\n_s(GameCanvas, \"Y8NLWKkLGYpCYHqDnL7BnUxkRo0=\");\n_c = GameCanvas;\nvar _c;\n$RefreshReg$(_c, \"GameCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvR2FtZUNhbnZhcy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDNkQ7QUFDRztBQUUzQjtBQUl0QixTQUFTTyxXQUFXLEtBQXdCO1FBQXhCLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFTLEdBQXhCOztJQUNqQyxNQUFNQyxZQUFZUiw2Q0FBTUEsQ0FBMkI7SUFDbkQsTUFBTSxDQUFDUyxXQUFXQyxhQUFhLEdBQUdULCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ1UsTUFBTUMsUUFBUSxHQUFHWCwrQ0FBUUEsQ0FBZ0I7SUFDaEQsTUFBTSxDQUFDWSxNQUFNQyxRQUFRLEdBQUdiLCtDQUFRQSxDQUFDO0lBQ2pDLE1BQU0sQ0FBQ2MsU0FBU0MsV0FBVyxHQUFHZiwrQ0FBUUEsQ0FBc0IsRUFBRTtJQUM5RCxNQUFNLENBQUNnQixZQUFZQyxjQUFjLEdBQUdqQiwrQ0FBUUEsQ0FBZ0I7SUFFNURILGdEQUFTQSxDQUFDO1FBQ1IsTUFBTXFCLFVBQVVmLGlEQUFPQSxDQUFDO1lBQ3RCZ0IsUUFBUSxJQUFNVixhQUFhO1lBQzNCVyxTQUFTLElBQU1YLGFBQWE7WUFDNUJZLFdBQVcsQ0FBQ0MsVUFBK0NYLFFBQVFXLFFBQVFaLElBQUk7WUFDL0VhLFlBQVksQ0FBQ0Q7Z0JBQ1hYLFFBQVFXLFFBQVFaLElBQUk7Z0JBQ3BCRyxRQUFRUyxRQUFRVixJQUFJO2dCQUNwQkcsV0FBV08sUUFBUVIsT0FBTztZQUM1QjtZQUNBVSxZQUFZLENBQUNGO2dCQUNYTCxjQUFjSyxRQUFRRyxNQUFNO1lBQzlCO1lBQ0FDLFVBQVU7Z0JBQ1IsMEVBQTBFO2dCQUMxRVQsY0FBYztZQUNoQjtRQUNGO1FBQ0EsTUFBTVUsUUFBUSxDQUFDQztZQUNiLElBQUlBLEVBQUVDLElBQUksS0FBSyxTQUFTO2dCQUN0QkQsRUFBRUUsY0FBYztnQkFDaEJDLE9BQU9DLGFBQWEsQ0FBQyxJQUFJQyxZQUFZO1lBQ3ZDO1FBQ0Y7UUFDQUYsT0FBT0csZ0JBQWdCLENBQUMsV0FBV1A7UUFDbkMsTUFBTVEsUUFBUSxJQUFNSixPQUFPQyxhQUFhLENBQUMsSUFBSUMsWUFBWTtRQUN6REYsT0FBT0csZ0JBQWdCLENBQUMsU0FBU0M7UUFDakMsT0FBTztZQUNMSixPQUFPSyxtQkFBbUIsQ0FBQyxXQUFXVDtZQUN0Q0ksT0FBT0ssbUJBQW1CLENBQUMsU0FBU0Q7WUFDcENqQixvQkFBQUEsOEJBQUFBO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCx5RUFBeUU7SUFDekUsTUFBTW1CLGNBQWN2Qyw4Q0FBT0EsQ0FBQztRQUMxQixJQUFJLENBQUNrQixZQUFZLE9BQU9zQjtRQUN4QixPQUFPeEIsUUFBUXlCLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFZixNQUFNLEtBQUtUO0lBQzFDLEdBQUc7UUFBQ0Y7UUFBU0U7S0FBVztJQUV4Qm5CLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSTRDLE1BQU07UUFDVixNQUFNQyxTQUFTbkMsVUFBVW9DLE9BQU87UUFDaEMsSUFBSSxDQUFDRCxRQUFRO1FBQ2IsTUFBTUUsTUFBTUMsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEtBQUssQ0FBQ2hCLE9BQU9pQixnQkFBZ0IsSUFBSTtRQUM5RCwyQ0FBMkM7UUFDM0NOLE9BQU9yQyxLQUFLLEdBQUd3QyxLQUFLRSxLQUFLLENBQUMxQyxRQUFRdUM7UUFDbENGLE9BQU9wQyxNQUFNLEdBQUd1QyxLQUFLRSxLQUFLLENBQUN6QyxTQUFTc0M7UUFDcENGLE9BQU9PLEtBQUssQ0FBQzVDLEtBQUssR0FBRyxHQUFTLE9BQU5BLE9BQU07UUFDOUJxQyxPQUFPTyxLQUFLLENBQUMzQyxNQUFNLEdBQUcsR0FBVSxPQUFQQSxRQUFPO1FBQ2hDLE1BQU00QyxNQUFNUixPQUFPUyxVQUFVLENBQUM7UUFDOUIsSUFBSSxDQUFDRCxLQUFLO1FBQ1ZBLElBQUlFLFlBQVksQ0FBQ1IsS0FBSyxHQUFHLEdBQUdBLEtBQUssR0FBRztRQUNwQyxNQUFNUyxTQUFTO1lBQ2JILElBQUlJLFNBQVMsQ0FBQyxHQUFHLEdBQUdqRCxPQUFPQztZQUMzQixhQUFhO1lBQ2I0QyxJQUFJSyxTQUFTLEdBQUc7WUFDaEJMLElBQUlNLFFBQVEsQ0FBQyxHQUFHLEdBQUduRCxPQUFPQztZQUUxQixrREFBa0Q7WUFDbEQsTUFBTW1ELFVBQVU7WUFDaEIsTUFBTUMsS0FBS3BELFNBQVNtRDtZQUNwQixpR0FBaUc7WUFDckcsTUFBTUUsVUFBVSxLQUFLLG1EQUFtRDtZQUNwRSxNQUFNQyxPQUFPdkIsY0FBY0EsWUFBWXdCLFFBQVEsR0FBRztZQUVsRCxtRUFBbUU7WUFDbkUsTUFBTUMsWUFBWTVELDREQUFnQkE7WUFDdEMsTUFBTTZELGFBQWFsQixLQUFLbUIsSUFBSSxDQUFDLENBQUMzRCxRQUFRc0QsT0FBTSxJQUFLRyxhQUFhO1lBQzlELE1BQU1HLGNBQWMsR0FBRyxtREFBbUQ7WUFFdEUsSUFBSXZELE1BQU07Z0JBQ1IsTUFBTXdELFFBQVFqRSwwREFBY0EsQ0FBQ1MsTUFBTUUsTUFBTTtvQkFBRXVELGFBQWFWO29CQUFTUTtvQkFBYUY7b0JBQVlLLGNBQWNSO2dCQUFLO2dCQUM3RyxLQUFLLE1BQU1wQixLQUFLMEIsTUFBTztvQkFDckIsTUFBTUcsVUFBVXhCLEtBQUt5QixLQUFLLENBQUNYLFVBQVduQixDQUFBQSxFQUFFK0IsQ0FBQyxHQUFHWCxJQUFHO29CQUMvQyxnRUFBZ0U7b0JBQ2hFLElBQUlTLFVBQVU3QixFQUFFbkMsS0FBSyxJQUFJLEtBQUtnRSxXQUFXaEUsT0FBTztvQkFDaEQsTUFBTW1FLE9BQU8sQ0FBQ2hDLEVBQUVpQyxVQUFVLEdBQUdqQyxFQUFFa0MsU0FBUyxHQUFHLEtBQUtoQjtvQkFDaEQsTUFBTWlCLE9BQU8sQ0FBQ25DLEVBQUVpQyxVQUFVLEdBQUdqQyxFQUFFa0MsU0FBUyxHQUFHLEtBQUtoQjtvQkFDaERSLElBQUlLLFNBQVMsR0FBRztvQkFDaEJMLElBQUlNLFFBQVEsQ0FBQ2EsU0FBUyxHQUFHN0IsRUFBRW5DLEtBQUssRUFBRW1FO29CQUNsQ3RCLElBQUlNLFFBQVEsQ0FBQ2EsU0FBU00sTUFBTW5DLEVBQUVuQyxLQUFLLEVBQUVDLFNBQVNxRTtnQkFDaEQ7WUFDRjtZQUVBLGtDQUFrQztZQUNsQ3pCLElBQUkwQixTQUFTLEdBQUc7WUFDaEIxQixJQUFJMkIsWUFBWSxHQUFHO1lBQ25CLE1BQU1DLFVBQVVqQyxLQUFLQyxHQUFHLENBQUMsSUFBSUQsS0FBS3lCLEtBQUssQ0FBQyxLQUFNaEUsQ0FBQUEsU0FBUyxHQUFFO1lBQ3pENEMsSUFBSTZCLElBQUksR0FBRyxHQUFXLE9BQVJELFNBQVE7WUFDdEIsS0FBSyxNQUFNRSxNQUFNbEUsUUFBUztnQkFDeEIsTUFBTXlELElBQUkxQixLQUFLeUIsS0FBSyxDQUFDWCxVQUFXcUIsQ0FBQUEsR0FBR25CLFFBQVEsR0FBR0QsSUFBRztnQkFDakQsTUFBTXFCLElBQUlELEdBQUdFLFFBQVEsQ0FBQ0QsQ0FBQyxHQUFJM0UsQ0FBQUEsU0FBUyxHQUFFO2dCQUN0QyxTQUFTO2dCQUNULE1BQU02RSxVQUFVOUMsZUFBZTJDLEdBQUd2RCxNQUFNLEtBQUtZLFlBQVlaLE1BQU07Z0JBQy9EeUIsSUFBSUssU0FBUyxHQUFHNEIsVUFBVSxZQUFZO2dCQUN0QyxNQUFNQyxLQUFLdkMsS0FBS0MsR0FBRyxDQUFDLElBQUlELEtBQUt5QixLQUFLLENBQUMsS0FBTWhFLENBQUFBLFNBQVMsR0FBRTtnQkFDcEQsTUFBTStFLEtBQUt4QyxLQUFLQyxHQUFHLENBQUMsSUFBSUQsS0FBS3lCLEtBQUssQ0FBQyxLQUFNaEUsQ0FBQUEsU0FBUyxHQUFFO2dCQUNwRDRDLElBQUlNLFFBQVEsQ0FBQ2UsR0FBR1UsR0FBR0csSUFBSUM7Z0JBQ3ZCLHFCQUFxQjtnQkFDckIsTUFBTUMsUUFBUSxDQUFDTixHQUFHTyxTQUFTLElBQUksR0FBRSxFQUFHQyxLQUFLLENBQUMsR0FBRztnQkFDN0N0QyxJQUFJSyxTQUFTLEdBQUc7Z0JBQ2hCTCxJQUFJdUMsUUFBUSxDQUFDSCxPQUFPZixJQUFJMUIsS0FBS3lCLEtBQUssQ0FBQ2MsS0FBSyxJQUFJSCxJQUFJO1lBQ2xEO1lBRUEsMkVBQTJFO1lBQzNFLElBQUksQ0FBQzVDLGFBQWE7Z0JBQ2hCLE1BQU0rQyxLQUFLdkMsS0FBS0MsR0FBRyxDQUFDLElBQUlELEtBQUt5QixLQUFLLENBQUMsS0FBTWhFLENBQUFBLFNBQVMsR0FBRTtnQkFDcEQsTUFBTStFLEtBQUt4QyxLQUFLQyxHQUFHLENBQUMsSUFBSUQsS0FBS3lCLEtBQUssQ0FBQyxLQUFNaEUsQ0FBQUEsU0FBUyxHQUFFO2dCQUNwRCxNQUFNaUUsSUFBSTFCLEtBQUt5QixLQUFLLENBQUNYO2dCQUNyQixNQUFNc0IsSUFBSXBDLEtBQUt5QixLQUFLLENBQUMsVUFBVyxNQUFPWjtnQkFDdkNSLElBQUlLLFNBQVMsR0FBRyxXQUFXLHdDQUF3QztnQkFDbkVMLElBQUlNLFFBQVEsQ0FBQ2UsR0FBR1UsR0FBR0csSUFBSUM7Z0JBQ3ZCbkMsSUFBSUssU0FBUyxHQUFHO2dCQUNoQkwsSUFBSXVDLFFBQVEsQ0FBQyxPQUFPbEIsSUFBSTFCLEtBQUt5QixLQUFLLENBQUNjLEtBQUssSUFBSUgsSUFBSTtZQUNsRDtZQUVBLDBDQUEwQztZQUMxQyxNQUFNUyxTQUFTbEYsWUFBWSxjQUFjO1lBQ3pDLE1BQU1tRixXQUFxQjtnQkFBQ0Q7YUFBTztZQUNuQyxNQUFNRSxLQUFLdkQ7WUFDWCxJQUFJdUQsSUFBSTtnQkFDTixNQUFNQyxPQUFPaEQsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEtBQUssQ0FBQzZDLEdBQUcvQixRQUFRO29CQUNqQytCO2dCQUFkLE1BQU1FLFFBQVFGLENBQUFBLFlBQUFBLEdBQUdFLEtBQUssY0FBUkYsdUJBQUFBLFlBQVk7Z0JBQzFCRCxTQUFTSSxJQUFJLENBQUMsVUFBZ0IsT0FBTkQ7Z0JBQ3hCSCxTQUFTSSxJQUFJLENBQUMsU0FBYyxPQUFMRixNQUFLO1lBQzlCO1lBQ0EsTUFBTUcsUUFBUTtZQUNkLE1BQU1DLE1BQU07WUFDWixNQUFNQyxPQUFPO1lBQ2IsTUFBTUMsT0FBT1IsU0FBU1MsTUFBTSxHQUFHSixRQUFRQyxNQUFNLElBQUk7WUFDakQsMkJBQTJCO1lBQzNCL0MsSUFBSUssU0FBUyxHQUFHO1lBQ2hCTCxJQUFJTSxRQUFRLENBQUMsR0FBRyxHQUFHMEMsTUFBTUM7WUFDekJqRCxJQUFJSyxTQUFTLEdBQUc7WUFDaEJMLElBQUk2QixJQUFJLEdBQUc7WUFDWDdCLElBQUkyQixZQUFZLEdBQUc7WUFDbkIzQixJQUFJMEIsU0FBUyxHQUFHO1lBQ2hCLElBQUl5QixPQUFPLElBQUlKLE1BQU07WUFDckIsS0FBSyxNQUFNSyxRQUFRWCxTQUFVO2dCQUMzQnpDLElBQUl1QyxRQUFRLENBQUNhLE1BQU0sSUFBSUQ7Z0JBQ3ZCQSxRQUFRTDtZQUNWO1lBRUF2RCxNQUFNOEQsc0JBQXNCbEQ7UUFDOUI7UUFDQVosTUFBTThELHNCQUFzQmxEO1FBQzVCLE9BQU8sSUFBTW1ELHFCQUFxQi9EO0lBQ3BDLEdBQUc7UUFBQ3BDO1FBQU9DO1FBQVFJO1FBQU1FO1FBQU1FO1FBQVNOO1FBQVdRO0tBQVc7SUFFOUQscUJBQU8sOERBQUMwQjtRQUFPK0QsS0FBS2xHO1FBQVdGLE9BQU9BO1FBQU9DLFFBQVFBOzs7Ozs7QUFDdkQ7R0EvSndCRjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0dhbWVDYW52YXMudHN4PzUyNmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGdldFBpcGVzQXRUaWNrLCBnZXRQaXBlU3BhY2luZ1B4IH0gZnJvbSBcIi4uL2xpYi90cmFja1wiO1xuaW1wb3J0IHR5cGUgeyBBY3RpdmVQbGF5ZXJTdGF0ZSwgU25hcHNob3RQYXlsb2FkIH0gZnJvbSBcIi4uLy4uL3NoYXJlZC90eXBlc1wiO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gXCIuLi9saWIvbmV0XCI7XG5cbnR5cGUgUHJvcHMgPSB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdhbWVDYW52YXMoeyB3aWR0aCwgaGVpZ2h0IH06IFByb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY29ubmVjdGVkLCBzZXRDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2VlZCwgc2V0U2VlZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3RpY2ssIHNldFRpY2tdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtwbGF5ZXJzLCBzZXRQbGF5ZXJzXSA9IHVzZVN0YXRlPEFjdGl2ZVBsYXllclN0YXRlW10+KFtdKTtcbiAgY29uc3QgW2xvY2FsUnVuSWQsIHNldExvY2FsUnVuSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwID0gY29ubmVjdCh7XG4gICAgICBvbk9wZW46ICgpID0+IHNldENvbm5lY3RlZCh0cnVlKSxcbiAgICAgIG9uQ2xvc2U6ICgpID0+IHNldENvbm5lY3RlZChmYWxzZSksXG4gICAgICBvbkpvaW5BY2s6IChwYXlsb2FkOiB7IHJvb21faWQ6IHN0cmluZzsgc2VlZDogc3RyaW5nIH0pID0+IHNldFNlZWQocGF5bG9hZC5zZWVkKSxcbiAgICAgIG9uU25hcHNob3Q6IChwYXlsb2FkOiBTbmFwc2hvdFBheWxvYWQpID0+IHtcbiAgICAgICAgc2V0U2VlZChwYXlsb2FkLnNlZWQpO1xuICAgICAgICBzZXRUaWNrKHBheWxvYWQudGljayk7XG4gICAgICAgIHNldFBsYXllcnMocGF5bG9hZC5wbGF5ZXJzKTtcbiAgICAgIH0sXG4gICAgICBvblJ1blN0YXJ0OiAocGF5bG9hZDogeyByb29tX2lkOiBzdHJpbmc7IHJ1bl9pZDogc3RyaW5nOyB0aWNrOiBudW1iZXIgfSkgPT4ge1xuICAgICAgICBzZXRMb2NhbFJ1bklkKHBheWxvYWQucnVuX2lkKTtcbiAgICAgIH0sXG4gICAgICBvblJ1bkVuZDogKCkgPT4ge1xuICAgICAgICAvLyBSZXNldCBsb2NhbCBydW4gc28gY2FtZXJhIHNuYXBzIGJhY2sgdG8gc3RhcnQgYW5kIGRvZXNuJ3QgZm9sbG93IG90aGVyc1xuICAgICAgICBzZXRMb2NhbFJ1bklkKG51bGwpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBvbktleSA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICBpZiAoZS5jb2RlID09PSBcIlNwYWNlXCIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJmbGFwXCIpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleSk7XG4gICAgY29uc3Qgb25UYXAgPSAoKSA9PiB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJmbGFwXCIpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uVGFwKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5KTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25UYXApO1xuICAgICAgY2xlYW51cD8uKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIERlcml2ZSB0aGUgbG9jYWwgcGxheWVyIGVudGl0eSBmb3IgdGhlIGFjdGl2ZSBydW4gaWYga25vd24gKGJ5IHJ1bl9pZClcbiAgY29uc3QgbG9jYWxQbGF5ZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWxvY2FsUnVuSWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHBsYXllcnMuZmluZCgocCkgPT4gcC5ydW5faWQgPT09IGxvY2FsUnVuSWQpO1xuICB9LCBbcGxheWVycywgbG9jYWxSdW5JZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IHJhZiA9IDA7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcbiAgICBjb25zdCBkcHIgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKTtcbiAgICAvLyBSZXNpemUgYmFja2luZyBzdG9yZSBmb3IgY3Jpc3AgcmVuZGVyaW5nXG4gICAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIGRwcik7XG4gICAgY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0ICogZHByKTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgIGNvbnN0IHJlbmRlciA9ICgpID0+IHtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAvLyBCYWNrZ3JvdW5kXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjMGUxNTIwXCI7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIFdvcmxkIHNjYWxpbmcgdG8gbWF0Y2ggc2VydmVyLXNpZGUgV09STERfSEVJR0hUXG4gICAgICBjb25zdCBXT1JMRF9IID0gNjAwO1xuICAgICAgY29uc3Qgc1kgPSBoZWlnaHQgLyBXT1JMRF9IO1xuICAgICAgLy8gQ2FtZXJhOiBhbmNob3Igb25seSB0byBsb2NhbCBwbGF5ZXIncyBkaXN0YW5jZTsgb3RoZXJ3aXNlIHN0YXkgYXQgb3JpZ2luIChkb24ndCBmb2xsb3cgb3RoZXJzKVxuICBjb25zdCBMRUFEX0lOID0gMTYwOyAvLyBwaXhlbHMgb2Ygc3BhY2UgYWhlYWQgb2YgcGxheWVyIG9uIHRoZSBsZWZ0IHNpZGVcbiAgICAgIGNvbnN0IGNhbVggPSBsb2NhbFBsYXllciA/IGxvY2FsUGxheWVyLmRpc3RhbmNlIDogMDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IHBpcGVzIHRvIHJlbmRlciBzbyB0aGV5IGZpbGwgdGhlIHNjcmVlbiB3aWR0aFxuICAgICAgY29uc3Qgc3BhY2luZ1B4ID0gZ2V0UGlwZVNwYWNpbmdQeCgpO1xuICBjb25zdCBjb3VudEFmdGVyID0gTWF0aC5jZWlsKCh3aWR0aCArIExFQURfSU4pIC8gc3BhY2luZ1B4KSArIDI7XG4gIGNvbnN0IGNvdW50QmVmb3JlID0gMzsgLy8gYSBiaXQgbW9yZSBoaXN0b3J5IHNvIHBpcGVzIGRvbid0IGRyb3AgdG9vIGVhcmx5XG5cbiAgICAgIGlmIChzZWVkKSB7XG4gICAgICAgIGNvbnN0IHBpcGVzID0gZ2V0UGlwZXNBdFRpY2soc2VlZCwgdGljaywgeyB3b3JsZEhlaWdodDogV09STERfSCwgY291bnRCZWZvcmUsIGNvdW50QWZ0ZXIsIGJhc2VEaXN0YW5jZTogY2FtWCB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBpcGVzKSB7XG4gICAgICAgICAgY29uc3Qgc2NyZWVuWCA9IE1hdGgucm91bmQoTEVBRF9JTiArIChwLnggLSBjYW1YKSk7XG4gICAgICAgICAgLy8gQ3VsbCBpZiBjb21wbGV0ZWx5IG9mZiBzY3JlZW4gKG5vbi1zdHJpY3QgdG8gYXZvaWQgZWFybHkgcG9wKVxuICAgICAgICAgIGlmIChzY3JlZW5YICsgcC53aWR0aCA8PSAwIHx8IHNjcmVlblggPj0gd2lkdGgpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHRvcEggPSAocC5nYXBDZW50ZXJZIC0gcC5nYXBIZWlnaHQgLyAyKSAqIHNZO1xuICAgICAgICAgIGNvbnN0IGJvdFkgPSAocC5nYXBDZW50ZXJZICsgcC5nYXBIZWlnaHQgLyAyKSAqIHNZO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMyMmM1NWVcIjtcbiAgICAgICAgICBjdHguZmlsbFJlY3Qoc2NyZWVuWCwgMCwgcC53aWR0aCwgdG9wSCk7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHNjcmVlblgsIGJvdFksIHAud2lkdGgsIGhlaWdodCAtIGJvdFkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXcgcGxheWVycyByZWxhdGl2ZSB0byBjYW1lcmFcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICBjb25zdCBsYWJlbFB4ID0gTWF0aC5tYXgoMTAsIE1hdGgucm91bmQoMTIgKiAoaGVpZ2h0IC8gNjAwKSkpO1xuICAgICAgY3R4LmZvbnQgPSBgJHtsYWJlbFB4fXB4IHN5c3RlbS11aWA7XG4gICAgICBmb3IgKGNvbnN0IHBsIG9mIHBsYXllcnMpIHtcbiAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoTEVBRF9JTiArIChwbC5kaXN0YW5jZSAtIGNhbVgpKTtcbiAgICAgICAgY29uc3QgeSA9IHBsLnBvc2l0aW9uLnkgKiAoaGVpZ2h0IC8gNjAwKTtcbiAgICAgICAgLy8gQXZhdGFyXG4gICAgICAgIGNvbnN0IGlzTG9jYWwgPSBsb2NhbFBsYXllciAmJiBwbC5ydW5faWQgPT09IGxvY2FsUGxheWVyLnJ1bl9pZDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGlzTG9jYWwgPyBcIiNmYmJmMjRcIiA6IFwiIzYwYTVmYVwiO1xuICAgICAgICBjb25zdCBhdyA9IE1hdGgubWF4KDE2LCBNYXRoLnJvdW5kKDI0ICogKGhlaWdodCAvIDYwMCkpKTtcbiAgICAgICAgY29uc3QgYWggPSBNYXRoLm1heCgxMiwgTWF0aC5yb3VuZCgxOCAqIChoZWlnaHQgLyA2MDApKSk7XG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCBhdywgYWgpO1xuICAgICAgICAvLyBMYWJlbCBhYm92ZSBhdmF0YXJcbiAgICAgICAgY29uc3QgbGFiZWwgPSAocGwucGxheWVyX2lkIHx8IFwiP1wiKS5zbGljZSgwLCA2KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2U1ZTdlYlwiO1xuICAgICAgICBjdHguZmlsbFRleHQobGFiZWwsIHggKyBNYXRoLnJvdW5kKGF3IC8gMiksIHkgLSA0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgeWV0IGhhdmUgYSBsb2NhbCBwbGF5ZXIgZnJvbSBzbmFwc2hvdHMsIHJlbmRlciBhIHBsYWNlaG9sZGVyXG4gICAgICBpZiAoIWxvY2FsUGxheWVyKSB7XG4gICAgICAgIGNvbnN0IGF3ID0gTWF0aC5tYXgoMTYsIE1hdGgucm91bmQoMjQgKiAoaGVpZ2h0IC8gNjAwKSkpO1xuICAgICAgICBjb25zdCBhaCA9IE1hdGgubWF4KDEyLCBNYXRoLnJvdW5kKDE4ICogKGhlaWdodCAvIDYwMCkpKTtcbiAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoTEVBRF9JTik7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKChXT1JMRF9IICogMC40KSAqIHNZKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZiYmYyNFwiOyAvLyBoaWdobGlnaHQgY29sb3IgZm9yIGxvY2FsIHBsYWNlaG9sZGVyXG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCBhdywgYWgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjZTVlN2ViXCI7XG4gICAgICAgIGN0eC5maWxsVGV4dChcIllvdVwiLCB4ICsgTWF0aC5yb3VuZChhdyAvIDIpLCB5IC0gNCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhVRCAocmVuZGVyIGxhc3QgdG8gZW5zdXJlIGl0J3Mgb24gdG9wKVxuICAgICAgY29uc3Qgc3RhdHVzID0gY29ubmVjdGVkID8gXCJDb25uZWN0ZWRcIiA6IFwiQ29ubmVjdGluZy4uLlwiO1xuICAgICAgY29uc3QgaHVkTGluZXM6IHN0cmluZ1tdID0gW3N0YXR1c107XG4gICAgICBjb25zdCBtZSA9IGxvY2FsUGxheWVyO1xuICAgICAgaWYgKG1lKSB7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKG1lLmRpc3RhbmNlKSk7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gbWUuc2NvcmUgPz8gMDtcbiAgICAgICAgaHVkTGluZXMucHVzaChgU2NvcmU6ICR7c2NvcmV9YCk7XG4gICAgICAgIGh1ZExpbmVzLnB1c2goYERpc3Q6ICR7ZGlzdH1weGApO1xuICAgICAgfVxuICAgICAgY29uc3QgbGluZUggPSAxODtcbiAgICAgIGNvbnN0IHBhZCA9IDg7XG4gICAgICBjb25zdCBodWRXID0gMTYwO1xuICAgICAgY29uc3QgaHVkSCA9IGh1ZExpbmVzLmxlbmd0aCAqIGxpbmVIICsgcGFkICogMiAtIDQ7XG4gICAgICAvLyBiYWNrZHJvcCBmb3IgcmVhZGFiaWxpdHlcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMiw2LDIzLDAuNilcIjtcbiAgICAgIGN0eC5maWxsUmVjdCg4LCA4LCBodWRXLCBodWRIKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNjYmQ1ZTFcIjtcbiAgICAgIGN0eC5mb250ID0gXCIxNHB4IHN5c3RlbS11aVwiO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICBsZXQgeU9mZiA9IDggKyBwYWQgLSAyO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGh1ZExpbmVzKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChsaW5lLCAxMiwgeU9mZik7XG4gICAgICAgIHlPZmYgKz0gbGluZUg7XG4gICAgICB9XG5cbiAgICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuICAgIH07XG4gICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG4gICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gIH0sIFt3aWR0aCwgaGVpZ2h0LCBzZWVkLCB0aWNrLCBwbGF5ZXJzLCBjb25uZWN0ZWQsIGxvY2FsUnVuSWRdKTtcblxuICByZXR1cm4gPGNhbnZhcyByZWY9e2NhbnZhc1JlZn0gd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gLz47XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwiZ2V0UGlwZXNBdFRpY2siLCJnZXRQaXBlU3BhY2luZ1B4IiwiY29ubmVjdCIsIkdhbWVDYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsImNhbnZhc1JlZiIsImNvbm5lY3RlZCIsInNldENvbm5lY3RlZCIsInNlZWQiLCJzZXRTZWVkIiwidGljayIsInNldFRpY2siLCJwbGF5ZXJzIiwic2V0UGxheWVycyIsImxvY2FsUnVuSWQiLCJzZXRMb2NhbFJ1bklkIiwiY2xlYW51cCIsIm9uT3BlbiIsIm9uQ2xvc2UiLCJvbkpvaW5BY2siLCJwYXlsb2FkIiwib25TbmFwc2hvdCIsIm9uUnVuU3RhcnQiLCJydW5faWQiLCJvblJ1bkVuZCIsIm9uS2V5IiwiZSIsImNvZGUiLCJwcmV2ZW50RGVmYXVsdCIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblRhcCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsb2NhbFBsYXllciIsInVuZGVmaW5lZCIsImZpbmQiLCJwIiwicmFmIiwiY2FudmFzIiwiY3VycmVudCIsImRwciIsIk1hdGgiLCJtYXgiLCJmbG9vciIsImRldmljZVBpeGVsUmF0aW8iLCJzdHlsZSIsImN0eCIsImdldENvbnRleHQiLCJzZXRUcmFuc2Zvcm0iLCJyZW5kZXIiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsIldPUkxEX0giLCJzWSIsIkxFQURfSU4iLCJjYW1YIiwiZGlzdGFuY2UiLCJzcGFjaW5nUHgiLCJjb3VudEFmdGVyIiwiY2VpbCIsImNvdW50QmVmb3JlIiwicGlwZXMiLCJ3b3JsZEhlaWdodCIsImJhc2VEaXN0YW5jZSIsInNjcmVlblgiLCJyb3VuZCIsIngiLCJ0b3BIIiwiZ2FwQ2VudGVyWSIsImdhcEhlaWdodCIsImJvdFkiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJsYWJlbFB4IiwiZm9udCIsInBsIiwieSIsInBvc2l0aW9uIiwiaXNMb2NhbCIsImF3IiwiYWgiLCJsYWJlbCIsInBsYXllcl9pZCIsInNsaWNlIiwiZmlsbFRleHQiLCJzdGF0dXMiLCJodWRMaW5lcyIsIm1lIiwiZGlzdCIsInNjb3JlIiwicHVzaCIsImxpbmVIIiwicGFkIiwiaHVkVyIsImh1ZEgiLCJsZW5ndGgiLCJ5T2ZmIiwibGluZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/GameCanvas.tsx\n"));

/***/ })

});