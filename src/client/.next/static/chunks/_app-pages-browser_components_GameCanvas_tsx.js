"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_components_GameCanvas_tsx"],{

/***/ "(app-pages-browser)/./components/GameCanvas.tsx":
/*!***********************************!*\
  !*** ./components/GameCanvas.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GameCanvas; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_track__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/track */ \"(app-pages-browser)/./lib/track.ts\");\n/* harmony import */ var _lib_net__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/net */ \"(app-pages-browser)/./lib/net.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction GameCanvas(param) {\n    let { width, height } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [seed, setSeed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [tick, setTick] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [players, setPlayers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [localRunId, setLocalRunId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const cleanup = (0,_lib_net__WEBPACK_IMPORTED_MODULE_3__.connect)({\n            onOpen: ()=>setConnected(true),\n            onClose: ()=>setConnected(false),\n            onJoinAck: (payload)=>setSeed(payload.seed),\n            onSnapshot: (payload)=>{\n                setSeed(payload.seed);\n                setTick(payload.tick);\n                setPlayers(payload.players);\n            },\n            onRunStart: (payload)=>{\n                setLocalRunId(payload.run_id);\n            },\n            onRunEnd: ()=>{\n                // Reset local run so camera snaps back to start and doesn't follow others\n                setLocalRunId(null);\n            }\n        });\n        const onKey = (e)=>{\n            if (e.code === \"Space\") {\n                e.preventDefault();\n                window.dispatchEvent(new CustomEvent(\"flap\"));\n            }\n        };\n        window.addEventListener(\"keydown\", onKey);\n        const onTap = ()=>window.dispatchEvent(new CustomEvent(\"flap\"));\n        window.addEventListener(\"click\", onTap);\n        return ()=>{\n            window.removeEventListener(\"keydown\", onKey);\n            window.removeEventListener(\"click\", onTap);\n            cleanup === null || cleanup === void 0 ? void 0 : cleanup();\n        };\n    }, []);\n    // Derive the local player entity for the active run if known (by run_id)\n    const localPlayer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!localRunId) return undefined;\n        return players.find((p)=>p.run_id === localRunId);\n    }, [\n        players,\n        localRunId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let raf = 0;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));\n        // Resize backing store for crisp rendering\n        canvas.width = Math.floor(width * dpr);\n        canvas.height = Math.floor(height * dpr);\n        canvas.style.width = \"\".concat(width, \"px\");\n        canvas.style.height = \"\".concat(height, \"px\");\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        const render = ()=>{\n            ctx.clearRect(0, 0, width, height);\n            // Background\n            ctx.fillStyle = \"#0e1520\";\n            ctx.fillRect(0, 0, width, height);\n            // World scaling to match server-side WORLD_HEIGHT\n            const WORLD_H = 600;\n            const sY = height / WORLD_H;\n            // Camera: anchor only to local player's distance; otherwise stay at origin (don't follow others)\n            const LEAD_IN = 160; // pixels of space ahead of player on the left side\n            const camX = localPlayer ? localPlayer.distance : 0;\n            // Determine how many pipes to render so they fill the screen width\n            const spacingPx = (0,_lib_track__WEBPACK_IMPORTED_MODULE_2__.getPipeSpacingPx)();\n            const countAfter = Math.ceil((width + LEAD_IN) / spacingPx) + 2;\n            const countBefore = 3; // a bit more history so pipes don't drop too early\n            if (seed) {\n                const pipes = (0,_lib_track__WEBPACK_IMPORTED_MODULE_2__.getPipesAtTick)(seed, tick, {\n                    worldHeight: WORLD_H,\n                    countBefore,\n                    countAfter,\n                    baseDistance: camX\n                });\n                for (const p of pipes){\n                    const screenX = Math.round(LEAD_IN + (p.x - camX));\n                    // Cull if completely off screen (non-strict to avoid early pop)\n                    if (screenX + p.width <= 0 || screenX >= width) continue;\n                    const topH = (p.gapCenterY - p.gapHeight / 2) * sY;\n                    const botY = (p.gapCenterY + p.gapHeight / 2) * sY;\n                    ctx.fillStyle = \"#22c55e\";\n                    ctx.fillRect(screenX, 0, p.width, topH);\n                    ctx.fillRect(screenX, botY, p.width, height - botY);\n                }\n            }\n            // Draw players relative to camera\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"bottom\";\n            const labelPx = Math.max(10, Math.round(12 * (height / 600)));\n            ctx.font = \"\".concat(labelPx, \"px system-ui\");\n            for (const pl of players){\n                const x = Math.round(LEAD_IN + (pl.distance - camX));\n                const y = pl.position.y * (height / 600);\n                // Avatar\n                const isLocal = localPlayer && pl.run_id === localPlayer.run_id;\n                ctx.fillStyle = isLocal ? \"#fbbf24\" : \"#60a5fa\";\n                const aw = Math.max(16, Math.round(24 * (height / 600)));\n                const ah = Math.max(12, Math.round(18 * (height / 600)));\n                ctx.fillRect(x, y, aw, ah);\n                // Label above avatar\n                const label = (pl.player_id || \"?\").slice(0, 6);\n                ctx.fillStyle = \"#e5e7eb\";\n                ctx.fillText(label, x + Math.round(aw / 2), y - 4);\n            }\n            // If we don't yet have a local player from snapshots, render a placeholder\n            if (!localPlayer) {\n                const aw = Math.max(16, Math.round(24 * (height / 600)));\n                const ah = Math.max(12, Math.round(18 * (height / 600)));\n                const x = Math.round(LEAD_IN);\n                const y = Math.round(WORLD_H * 0.4 * sY);\n                ctx.fillStyle = \"#fbbf24\"; // highlight color for local placeholder\n                ctx.fillRect(x, y, aw, ah);\n                ctx.fillStyle = \"#e5e7eb\";\n                ctx.fillText(\"You\", x + Math.round(aw / 2), y - 4);\n            }\n            // HUD (render last to ensure it's on top)\n            const status = connected ? \"Connected\" : \"Connecting...\";\n            const hudLines = [\n                status\n            ];\n            const me = localPlayer;\n            if (me) {\n                const dist = Math.max(0, Math.floor(me.distance));\n                var _me_score;\n                const score = (_me_score = me.score) !== null && _me_score !== void 0 ? _me_score : 0;\n                hudLines.push(\"Score: \".concat(score));\n                hudLines.push(\"Dist: \".concat(dist, \"px\"));\n            }\n            const lineH = 18;\n            const pad = 8;\n            const hudW = 160;\n            const hudH = hudLines.length * lineH + pad * 2 - 4;\n            // backdrop for readability\n            ctx.fillStyle = \"rgba(2,6,23,0.6)\";\n            ctx.fillRect(8, 8, hudW, hudH);\n            ctx.fillStyle = \"#cbd5e1\";\n            ctx.font = \"14px system-ui\";\n            ctx.textBaseline = \"top\";\n            ctx.textAlign = \"left\";\n            let yOff = 8 + pad - 2;\n            for (const line of hudLines){\n                ctx.fillText(line, 12, yOff);\n                yOff += lineH;\n            }\n            raf = requestAnimationFrame(render);\n        };\n        raf = requestAnimationFrame(render);\n        return ()=>cancelAnimationFrame(raf);\n    }, [\n        width,\n        height,\n        seed,\n        tick,\n        players,\n        connected,\n        localRunId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: width,\n        height: height\n    }, void 0, false, {\n        fileName: \"/Users/richardalvarez/Dev/flappy-multiplayer/src/client/components/GameCanvas.tsx\",\n        lineNumber: 167,\n        columnNumber: 10\n    }, this);\n}\n_s(GameCanvas, \"Y8NLWKkLGYpCYHqDnL7BnUxkRo0=\");\n_c = GameCanvas;\nvar _c;\n$RefreshReg$(_c, \"GameCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvR2FtZUNhbnZhcy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDNkQ7QUFDRztBQUUzQjtBQUl0QixTQUFTTyxXQUFXLEtBQXdCO1FBQXhCLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFTLEdBQXhCOztJQUNqQyxNQUFNQyxZQUFZUiw2Q0FBTUEsQ0FBMkI7SUFDbkQsTUFBTSxDQUFDUyxXQUFXQyxhQUFhLEdBQUdULCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ1UsTUFBTUMsUUFBUSxHQUFHWCwrQ0FBUUEsQ0FBZ0I7SUFDaEQsTUFBTSxDQUFDWSxNQUFNQyxRQUFRLEdBQUdiLCtDQUFRQSxDQUFDO0lBQ2pDLE1BQU0sQ0FBQ2MsU0FBU0MsV0FBVyxHQUFHZiwrQ0FBUUEsQ0FBc0IsRUFBRTtJQUM5RCxNQUFNLENBQUNnQixZQUFZQyxjQUFjLEdBQUdqQiwrQ0FBUUEsQ0FBZ0I7SUFFNURILGdEQUFTQSxDQUFDO1FBQ1IsTUFBTXFCLFVBQVVmLGlEQUFPQSxDQUFDO1lBQ3RCZ0IsUUFBUSxJQUFNVixhQUFhO1lBQzNCVyxTQUFTLElBQU1YLGFBQWE7WUFDNUJZLFdBQVcsQ0FBQ0MsVUFBK0NYLFFBQVFXLFFBQVFaLElBQUk7WUFDL0VhLFlBQVksQ0FBQ0Q7Z0JBQ1hYLFFBQVFXLFFBQVFaLElBQUk7Z0JBQ3BCRyxRQUFRUyxRQUFRVixJQUFJO2dCQUNwQkcsV0FBV08sUUFBUVIsT0FBTztZQUM1QjtZQUNBVSxZQUFZLENBQUNGO2dCQUNYTCxjQUFjSyxRQUFRRyxNQUFNO1lBQzlCO1lBQ0FDLFVBQVU7Z0JBQ1IsMEVBQTBFO2dCQUMxRVQsY0FBYztZQUNoQjtRQUNGO1FBQ0EsTUFBTVUsUUFBUSxDQUFDQztZQUNiLElBQUlBLEVBQUVDLElBQUksS0FBSyxTQUFTO2dCQUN0QkQsRUFBRUUsY0FBYztnQkFDaEJDLE9BQU9DLGFBQWEsQ0FBQyxJQUFJQyxZQUFZO1lBQ3ZDO1FBQ0Y7UUFDQUYs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LElBQUk7WUFDakQsMkJBQTJCO1lBQzNCL0MsSUFBSUssU0FBUyxHQUFHO1lBQ2hCTCxJQUFJTSxRQUFRLENBQUMsR0FBRyxHQUFHMEMsTUFBTUM7WUFDekJqRCxJQUFJSyxTQUFTLEdBQUc7WUFDaEJMLElBQUk2QixJQUFJLEdBQUc7WUFDWDdCLElBQUkyQixZQUFZLEdBQUc7WUFDbkIzQixJQUFJMEIsU0FBUyxHQUFHO1lBQ2hCLElBQUl5QixPQUFPLElBQUlKLE1BQU07WUFDckIsS0FBSyxNQUFNSyxRQUFRWCxTQUFVO2dCQUMzQnpDLElBQUl1QyxRQUFRLENBQUNhLE1BQU0sSUFBSUQ7Z0JBQ3ZCQSxRQUFRTDtZQUNWO1lBRUF2RCxNQUFNOEQsc0JBQXNCbEQ7UUFDOUI7UUFDQVosTUFBTThELHNCQUFzQmxEO1FBQzVCLE9BQU8sSUFBTW1ELHFCQUFxQi9EO0lBQ3BDLEdBQUc7UUFBQ3BDO1FBQU9DO1FBQVFJO1FBQU1FO1FBQU1FO1FBQVNOO1FBQVdRO0tBQVc7SUFFOUQscUJBQU8sOERBQUMwQjtRQUFPK0QsS0FBS2xHO1FBQVdGLE9BQU9BO1FBQU9DLFFBQVFBOzs7Ozs7QUFDdkQ7R0EvSndCRjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0dhbWVDYW52YXMudHN4PzUyNmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGdldFBpcGVzQXRUaWNrLCBnZXRQaXBlU3BhY2luZ1B4IH0gZnJvbSBcIi4uL2xpYi90cmFja1wiO1xuaW1wb3J0IHR5cGUgeyBBY3RpdmVQbGF5ZXJTdGF0ZSwgU25hcHNob3RQYXlsb2FkIH0gZnJvbSBcIi4uLy4uL3NoYXJlZC90eXBlc1wiO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gXCIuLi9saWIvbmV0XCI7XG5cbnR5cGUgUHJvcHMgPSB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdhbWVDYW52YXMoeyB3aWR0aCwgaGVpZ2h0IH06IFByb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY29ubmVjdGVkLCBzZXRDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2VlZCwgc2V0U2VlZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3RpY2ssIHNldFRpY2tdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtwbGF5ZXJzLCBzZXRQbGF5ZXJzXSA9IHVzZVN0YXRlPEFjdGl2ZVBsYXllclN0YXRlW10+KFtdKTtcbiAgY29uc3QgW2xvY2FsUnVuSWQsIHNldExvY2FsUnVuSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwID0gY29ubmVjdCh7XG4gICAgICBvbk9wZW46ICgpID0+IHNldENvbm5lY3RlZCh0cnVlKSxcbiAgICAgIG9uQ2xvc2U6ICgpID0+IHNldENvbm5lY3RlZChmYWxzZSksXG4gICAgICBvbkpvaW5BY2s6IChwYXlsb2FkOiB7IHJvb21faWQ6IHN0cmluZzsgc2VlZDogc3RyaW5nIH0pID0+IHNldFNlZWQocGF5bG9hZC5zZWVkKSxcbiAgICAgIG9uU25hcHNob3Q6IChwYXlsb2FkOiBTbmFwc2hvdFBheWxvYWQpID0+IHtcbiAgICAgICAgc2V0U2VlZChwYXlsb2FkLnNlZWQpO1xuICAgICAgICBzZXRUaWNrKHBheWxvYWQudGljayk7XG4gICAgICAgIHNldFBsYXllcnMocGF5bG9hZC5wbGF5ZXJzKTtcbiAgICAgIH0sXG4gICAgICBvblJ1blN0YXJ0OiAocGF5bG9hZDogeyByb29tX2lkOiBzdHJpbmc7IHJ1bl9pZDogc3RyaW5nOyB0aWNrOiBudW1iZXIgfSkgPT4ge1xuICAgICAgICBzZXRMb2NhbFJ1bklkKHBheWxvYWQucnVuX2lkKTtcbiAgICAgIH0sXG4gICAgICBvblJ1bkVuZDogKCkgPT4ge1xuICAgICAgICAvLyBSZXNldCBsb2NhbCBydW4gc28gY2FtZXJhIHNuYXBzIGJhY2sgdG8gc3RhcnQgYW5kIGRvZXNuJ3QgZm9sbG93IG90aGVyc1xuICAgICAgICBzZXRMb2NhbFJ1bklkKG51bGwpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBvbktleSA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICBpZiAoZS5jb2RlID09PSBcIlNwYWNlXCIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJmbGFwXCIpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleSk7XG4gICAgY29uc3Qgb25UYXAgPSAoKSA9PiB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJmbGFwXCIpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uVGFwKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5KTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25UYXApO1xuICAgICAgY2xlYW51cD8uKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIERlcml2ZSB0aGUgbG9jYWwgcGxheWVyIGVudGl0eSBmb3IgdGhlIGFjdGl2ZSBydW4gaWYga25vd24gKGJ5IHJ1bl9pZClcbiAgY29uc3QgbG9jYWxQbGF5ZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWxvY2FsUnVuSWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHBsYXllcnMuZmluZCgocCkgPT4gcC5ydW5faWQgPT09IGxvY2FsUnVuSWQpO1xuICB9LCBbcGxheWVycywgbG9jYWxSdW5JZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IHJhZiA9IDA7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcbiAgICBjb25zdCBkcHIgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKTtcbiAgICAvLyBSZXNpemUgYmFja2luZyBzdG9yZSBmb3IgY3Jpc3AgcmVuZGVyaW5nXG4gICAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIGRwcik7XG4gICAgY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0ICogZHByKTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgIGNvbnN0IHJlbmRlciA9ICgpID0+IHtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAvLyBCYWNrZ3JvdW5kXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjMGUxNTIwXCI7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIFdvcmxkIHNjYWxpbmcgdG8gbWF0Y2ggc2VydmVyLXNpZGUgV09STERfSEVJR0hUXG4gICAgICBjb25zdCBXT1JMRF9IID0gNjAwO1xuICAgICAgY29uc3Qgc1kgPSBoZWlnaHQgLyBXT1JMRF9IO1xuICAgICAgLy8gQ2FtZXJhOiBhbmNob3Igb25seSB0byBsb2NhbCBwbGF5ZXIncyBkaXN0YW5jZTsgb3RoZXJ3aXNlIHN0YXkgYXQgb3JpZ2luIChkb24ndCBmb2xsb3cgb3RoZXJzKVxuICBjb25zdCBMRUFEX0lOID0gMTYwOyAvLyBwaXhlbHMgb2Ygc3BhY2UgYWhlYWQgb2YgcGxheWVyIG9uIHRoZSBsZWZ0IHNpZGVcbiAgICAgIGNvbnN0IGNhbVggPSBsb2NhbFBsYXllciA/IGxvY2FsUGxheWVyLmRpc3RhbmNlIDogMDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IHBpcGVzIHRvIHJlbmRlciBzbyB0aGV5IGZpbGwgdGhlIHNjcmVlbiB3aWR0aFxuICAgICAgY29uc3Qgc3BhY2luZ1B4ID0gZ2V0UGlwZVNwYWNpbmdQeCgpO1xuICBjb25zdCBjb3VudEFmdGVyID0gTWF0aC5jZWlsKCh3aWR0aCArIExFQURfSU4pIC8gc3BhY2luZ1B4KSArIDI7XG4gIGNvbnN0IGNvdW50QmVmb3JlID0gMzsgLy8gYSBiaXQgbW9yZSBoaXN0b3J5IHNvIHBpcGVzIGRvbid0IGRyb3AgdG9vIGVhcmx5XG5cbiAgICAgIGlmIChzZWVkKSB7XG4gICAgICAgIGNvbnN0IHBpcGVzID0gZ2V0UGlwZXNBdFRpY2soc2VlZCwgdGljaywgeyB3b3JsZEhlaWdodDogV09STERfSCwgY291bnRCZWZvcmUsIGNvdW50QWZ0ZXIsIGJhc2VEaXN0YW5jZTogY2FtWCB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBpcGVzKSB7XG4gICAgICAgICAgY29uc3Qgc2NyZWVuWCA9IE1hdGgucm91bmQoTEVBRF9JTiArIChwLnggLSBjYW1YKSk7XG4gICAgICAgICAgLy8gQ3VsbCBpZiBjb21wbGV0ZWx5IG9mZiBzY3JlZW4gKG5vbi1zdHJpY3QgdG8gYXZvaWQgZWFybHkgcG9wKVxuICAgICAgICAgIGlmIChzY3JlZW5YICsgcC53aWR0aCA8PSAwIHx8IHNjcmVlblggPj0gd2lkdGgpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHRvcEggPSAocC5nYXBDZW50ZXJZIC0gcC5nYXBIZWlnaHQgLyAyKSAqIHNZO1xuICAgICAgICAgIGNvbnN0IGJvdFkgPSAocC5nYXBDZW50ZXJZICsgcC5nYXBIZWlnaHQgLyAyKSAqIHNZO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMyMmM1NWVcIjtcbiAgICAgICAgICBjdHguZmlsbFJlY3Qoc2NyZWVuWCwgMCwgcC53aWR0aCwgdG9wSCk7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHNjcmVlblgsIGJvdFksIHAud2lkdGgsIGhlaWdodCAtIGJvdFkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXcgcGxheWVycyByZWxhdGl2ZSB0byBjYW1lcmFcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICBjb25zdCBsYWJlbFB4ID0gTWF0aC5tYXgoMTAsIE1hdGgucm91bmQoMTIgKiAoaGVpZ2h0IC8gNjAwKSkpO1xuICAgICAgY3R4LmZvbnQgPSBgJHtsYWJlbFB4fXB4IHN5c3RlbS11aWA7XG4gICAgICBmb3IgKGNvbnN0IHBsIG9mIHBsYXllcnMpIHtcbiAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoTEVBRF9JTiArIChwbC5kaXN0YW5jZSAtIGNhbVgpKTtcbiAgICAgICAgY29uc3QgeSA9IHBsLnBvc2l0aW9uLnkgKiAoaGVpZ2h0IC8gNjAwKTtcbiAgICAgICAgLy8gQXZhdGFyXG4gICAgICAgIGNvbnN0IGlzTG9jYWwgPSBsb2NhbFBsYXllciAmJiBwbC5ydW5faWQgPT09IGxvY2FsUGxheWVyLnJ1bl9pZDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGlzTG9jYWwgPyBcIiNmYmJmMjRcIiA6IFwiIzYwYTVmYVwiO1xuICAgICAgICBjb25zdCBhdyA9IE1hdGgubWF4KDE2LCBNYXRoLnJvdW5kKDI0ICogKGhlaWdodCAvIDYwMCkpKTtcbiAgICAgICAgY29uc3QgYWggPSBNYXRoLm1heCgxMiwgTWF0aC5yb3VuZCgxOCAqIChoZWlnaHQgLyA2MDApKSk7XG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCBhdywgYWgpO1xuICAgICAgICAvLyBMYWJlbCBhYm92ZSBhdmF0YXJcbiAgICAgICAgY29uc3QgbGFiZWwgPSAocGwucGxheWVyX2lkIHx8IFwiP1wiKS5zbGljZSgwLCA2KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2U1ZTdlYlwiO1xuICAgICAgICBjdHguZmlsbFRleHQobGFiZWwsIHggKyBNYXRoLnJvdW5kKGF3IC8gMiksIHkgLSA0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgeWV0IGhhdmUgYSBsb2NhbCBwbGF5ZXIgZnJvbSBzbmFwc2hvdHMsIHJlbmRlciBhIHBsYWNlaG9sZGVyXG4gICAgICBpZiAoIWxvY2FsUGxheWVyKSB7XG4gICAgICAgIGNvbnN0IGF3ID0gTWF0aC5tYXgoMTYsIE1hdGgucm91bmQoMjQgKiAoaGVpZ2h0IC8gNjAwKSkpO1xuICAgICAgICBjb25zdCBhaCA9IE1hdGgubWF4KDEyLCBNYXRoLnJvdW5kKDE4ICogKGhlaWdodCAvIDYwMCkpKTtcbiAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoTEVBRF9JTik7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKChXT1JMRF9IICogMC40KSAqIHNZKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZiYmYyNFwiOyAvLyBoaWdobGlnaHQgY29sb3IgZm9yIGxvY2FsIHBsYWNlaG9sZGVyXG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCBhdywgYWgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjZTVlN2ViXCI7XG4gICAgICAgIGN0eC5maWxsVGV4dChcIllvdVwiLCB4ICsgTWF0aC5yb3VuZChhdyAvIDIpLCB5IC0gNCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhVRCAocmVuZGVyIGxhc3QgdG8gZW5zdXJlIGl0J3Mgb24gdG9wKVxuICAgICAgY29uc3Qgc3RhdHVzID0gY29ubmVjdGVkID8gXCJDb25uZWN0ZWRcIiA6IFwiQ29ubmVjdGluZy4uLlwiO1xuICAgICAgY29uc3QgaHVkTGluZXM6IHN0cmluZ1tdID0gW3N0YXR1c107XG4gICAgICBjb25zdCBtZSA9IGxvY2FsUGxheWVyO1xuICAgICAgaWYgKG1lKSB7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKG1lLmRpc3RhbmNlKSk7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gbWUuc2NvcmUgPz8gMDtcbiAgICAgICAgaHVkTGluZXMucHVzaChgU2NvcmU6ICR7c2NvcmV9YCk7XG4gICAgICAgIGh1ZExpbmVzLnB1c2goYERpc3Q6ICR7ZGlzdH1weGApO1xuICAgICAgfVxuICAgICAgY29uc3QgbGluZUggPSAxODtcbiAgICAgIGNvbnN0IHBhZCA9IDg7XG4gICAgICBjb25zdCBodWRXID0gMTYwO1xuICAgICAgY29uc3QgaHVkSCA9IGh1ZExpbmVzLmxlbmd0aCAqIGxpbmVIICsgcGFkICogMiAtIDQ7XG4gICAgICAvLyBiYWNrZHJvcCBmb3IgcmVhZGFiaWxpdHlcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMiw2LDIzLDAuNilcIjtcbiAgICAgIGN0eC5maWxsUmVjdCg4LCA4LCBodWRXLCBodWRIKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNjYmQ1ZTFcIjtcbiAgICAgIGN0eC5mb250ID0gXCIxNHB4IHN5c3RlbS11aVwiO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICBsZXQgeU9mZiA9IDggKyBwYWQgLSAyO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGh1ZExpbmVzKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChsaW5lLCAxMiwgeU9mZik7XG4gICAgICAgIHlPZmYgKz0gbGluZUg7XG4gICAgICB9XG5cbiAgICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuICAgIH07XG4gICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG4gICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gIH0sIFt3aWR0aCwgaGVpZ2h0LCBzZWVkLCB0aWNrLCBwbGF5ZXJzLCBjb25uZWN0ZWQsIGxvY2FsUnVuSWRdKTtcblxuICByZXR1cm4gPGNhbnZhcyByZWY9e2NhbnZhc1JlZn0gd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gLz47XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwiZ2V0UGlwZXNBdFRpY2siLCJnZXRQaXBlU3BhY2luZ1B4IiwiY29ubmVjdCIsIkdhbWVDYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsImNhbnZhc1JlZiIsImNvbm5lY3RlZCIsInNldENvbm5lY3RlZCIsInNlZWQiLCJzZXRTZWVkIiwidGljayIsInNldFRpY2siLCJwbGF5ZXJzIiwic2V0UGxheWVycyIsImxvY2FsUnVuSWQiLCJzZXRMb2NhbFJ1bklkIiwiY2xlYW51cCIsIm9uT3BlbiIsIm9uQ2xvc2UiLCJvbkpvaW5BY2siLCJwYXlsb2FkIiwib25TbmFwc2hvdCIsIm9uUnVuU3RhcnQiLCJydW5faWQiLCJvblJ1bkVuZCIsIm9uS2V5IiwiZSIsImNvZGUiLCJwcmV2ZW50RGVmYXVsdCIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblRhcCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsb2NhbFBsYXllciIsInVuZGVmaW5lZCIsImZpbmQiLCJwIiwicmFmIiwiY2FudmFzIiwiY3VycmVudCIsImRwciIsIk1hdGgiLCJtYXgiLCJmbG9vciIsImRldmljZVBpeGVsUmF0aW8iLCJzdHlsZSIsImN0eCIsImdldENvbnRleHQiLCJzZXRUcmFuc2Zvcm0iLCJyZW5kZXIiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsIldPUkxEX0giLCJzWSIsIkxFQURfSU4iLCJjYW1YIiwiZGlzdGFuY2UiLCJzcGFjaW5nUHgiLCJjb3VudEFmdGVyIiwiY2VpbCIsImNvdW50QmVmb3JlIiwicGlwZXMiLCJ3b3JsZEhlaWdodCIsImJhc2VEaXN0YW5jZSIsInNjcmVlblgiLCJyb3VuZCIsIngiLCJ0b3BIIiwiZ2FwQ2VudGVyWSIsImdhcEhlaWdodCIsImJvdFkiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJsYWJlbFB4IiwiZm9udCIsInBsIiwieSIsInBvc2l0aW9uIiwiaXNMb2NhbCIsImF3IiwiYWgiLCJsYWJlbCIsInBsYXllcl9pZCIsInNsaWNlIiwiZmlsbFRleHQiLCJzdGF0dXMiLCJodWRMaW5lcyIsIm1lIiwiZGlzdCIsInNjb3JlIiwicHVzaCIsImxpbmVIIiwicGFkIiwiaHVkVyIsImh1ZEgiLCJsZW5ndGgiLCJ5T2ZmIiwibGluZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/GameCanvas.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/net.ts":
/*!********************!*\
  !*** ./lib/net.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connect: function() { return /* binding */ connect; }\n/* harmony export */ });\nfunction connect(h) {\n    // In dev, assume server on ws://localhost:3001\n    const url = \"ws://localhost:3001\" || 0;\n    const ws = new WebSocket(url);\n    const send = (obj)=>ws.readyState === ws.OPEN && ws.send(JSON.stringify(obj));\n    ws.addEventListener(\"open\", ()=>{\n        var _h_onOpen;\n        (_h_onOpen = h.onOpen) === null || _h_onOpen === void 0 ? void 0 : _h_onOpen.call(h);\n        // Join immediately\n        send({\n            protocol_version: \"1\",\n            type: \"join.request\",\n            payload: {}\n        });\n    });\n    ws.addEventListener(\"close\", ()=>{\n        var _h_onClose;\n        return (_h_onClose = h.onClose) === null || _h_onClose === void 0 ? void 0 : _h_onClose.call(h);\n    });\n    ws.addEventListener(\"message\", (ev)=>{\n        try {\n            var _h_onJoinAck, _h_onSnapshot, _h_onRunStart, _h_onRunEnd;\n            const msg = JSON.parse(ev.data.toString());\n            const type = msg === null || msg === void 0 ? void 0 : msg.type;\n            const payload = msg === null || msg === void 0 ? void 0 : msg.payload;\n            if (type === \"join.ack\") (_h_onJoinAck = h.onJoinAck) === null || _h_onJoinAck === void 0 ? void 0 : _h_onJoinAck.call(h, payload);\n            else if (type === \"snapshot.event\") (_h_onSnapshot = h.onSnapshot) === null || _h_onSnapshot === void 0 ? void 0 : _h_onSnapshot.call(h, payload);\n            else if (type === \"runStart.event\") (_h_onRunStart = h.onRunStart) === null || _h_onRunStart === void 0 ? void 0 : _h_onRunStart.call(h, payload);\n            else if (type === \"runEnd.event\") (_h_onRunEnd = h.onRunEnd) === null || _h_onRunEnd === void 0 ? void 0 : _h_onRunEnd.call(h, payload);\n        } catch (e) {}\n    });\n    const onFlap = ()=>{\n        send({\n            protocol_version: \"1\",\n            type: \"input.flap.request\",\n            payload: {\n                nonce: Math.random().toString(36).slice(2)\n            }\n        });\n    };\n    window.addEventListener(\"flap\", onFlap);\n    return ()=>{\n        window.removeEventListener(\"flap\", onFlap);\n        try {\n            ws.close();\n        } catch (e) {}\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9uZXQudHMiLCJtYXBwaW5ncyI6Ijs7OztBQVdPLFNBQVNBLFFBQVFDLENBQVc7SUFDakMsK0NBQStDO0lBQy9DLE1BQU1DLE1BQU1DLHFCQUE4QixJQUFJLENBQXFCO0lBQ25FLE1BQU1HLEtBQUssSUFBSUMsVUFBVUw7SUFFekIsTUFBTU0sT0FBTyxDQUFDQyxNQUFhSCxHQUFHSSxVQUFVLEtBQUtKLEdBQUdLLElBQUksSUFBSUwsR0FBR0UsSUFBSSxDQUFDSSxLQUFLQyxTQUFTLENBQUNKO0lBRS9FSCxHQUFHUSxnQkFBZ0IsQ0FBQyxRQUFRO1lBQzFCYjtTQUFBQSxZQUFBQSxFQUFFYyxNQUFNLGNBQVJkLGdDQUFBQSxlQUFBQTtRQUNBLG1CQUFtQjtRQUNuQk8sS0FBSztZQUFFUSxrQkFBa0I7WUFBS0MsTUFBTTtZQUFnQkMsU0FBUyxDQUFDO1FBQUU7SUFDbEU7SUFDQVosR0FBR1EsZ0JBQWdCLENBQUMsU0FBUztZQUFNYjtnQkFBQUEsYUFBQUEsRUFBRWtCLE9BQU8sY0FBVGxCLGlDQUFBQSxnQkFBQUE7O0lBQ25DSyxHQUFHUSxnQkFBZ0IsQ0FBQyxXQUFXLENBQUNNO1FBQzlCLElBQUk7Z0JBSXVCbkIsY0FDV0EsZUFDQUEsZUFDRkE7WUFObEMsTUFBTW9CLE1BQU1ULEtBQUtVLEtBQUssQ0FBQ0YsR0FBR0csSUFBSSxDQUFDQyxRQUFRO1lBQ3ZDLE1BQU1QLE9BQU9JLGdCQUFBQSwwQkFBQUEsSUFBS0osSUFBSTtZQUN0QixNQUFNQyxVQUFVRyxnQkFBQUEsMEJBQUFBLElBQUtILE9BQU87WUFDNUIsSUFBSUQsU0FBUyxhQUFZaEIsZUFBQUEsRUFBRXdCLFNBQVMsY0FBWHhCLG1DQUFBQSxrQkFBQUEsR0FBY2lCO2lCQUNsQyxJQUFJRCxTQUFTLG1CQUFrQmhCLGdCQUFBQSxFQUFFeUIsVUFBVSxjQUFaekIsb0NBQUFBLG1CQUFBQSxHQUFlaUI7aUJBQzlDLElBQUlELFNBQVMsbUJBQWtCaEIsZ0JBQUFBLEVBQUUwQixVQUFVLGNBQVoxQixvQ0FBQUEsbUJBQUFBLEdBQWVpQjtpQkFDOUMsSUFBSUQsU0FBUyxpQkFBZ0JoQixjQUFBQSxFQUFFMkIsUUFBUSxjQUFWM0Isa0NBQUFBLGlCQUFBQSxHQUFhaUI7UUFDakQsRUFBRSxVQUFNLENBQUM7SUFDWDtJQUVBLE1BQU1XLFNBQVM7UUFDYnJCLEtBQUs7WUFBRVEsa0JBQWtCO1lBQUtDLE1BQU07WUFBc0JDLFNBQVM7Z0JBQUVZLE9BQU9DLEtBQUtDLE1BQU0sR0FBR1IsUUFBUSxDQUFDLElBQUlTLEtBQUssQ0FBQztZQUFHO1FBQUU7SUFDcEg7SUFDQUMsT0FBT3BCLGdCQUFnQixDQUFDLFFBQVFlO0lBRWhDLE9BQU87UUFDTEssT0FBT0MsbUJBQW1CLENBQUMsUUFBUU47UUFDbkMsSUFBSTtZQUFFdkIsR0FBRzhCLEtBQUs7UUFBSSxFQUFFLFVBQU0sQ0FBQztJQUM3QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9uZXQudHM/NmFiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNuYXBzaG90UGF5bG9hZCB9IGZyb20gXCIuLi8uLi9zaGFyZWQvdHlwZXNcIjtcblxuaW50ZXJmYWNlIEhhbmRsZXJzIHtcbiAgb25PcGVuPzogKCkgPT4gdm9pZDtcbiAgb25DbG9zZT86ICgpID0+IHZvaWQ7XG4gIG9uSm9pbkFjaz86IChwYXlsb2FkOiB7IHJvb21faWQ6IHN0cmluZzsgc2VlZDogc3RyaW5nIH0pID0+IHZvaWQ7XG4gIG9uU25hcHNob3Q/OiAocGF5bG9hZDogU25hcHNob3RQYXlsb2FkKSA9PiB2b2lkO1xuICBvblJ1blN0YXJ0PzogKHBheWxvYWQ6IHsgcm9vbV9pZDogc3RyaW5nOyBydW5faWQ6IHN0cmluZzsgdGljazogbnVtYmVyIH0pID0+IHZvaWQ7XG4gIG9uUnVuRW5kPzogKHBheWxvYWQ6IHsgcm9vbV9pZDogc3RyaW5nOyBydW5faWQ6IHN0cmluZzsgZmluYWxfZGlzdGFuY2U6IG51bWJlcjsgZmluYWxfc2NvcmU6IG51bWJlcjsgcmVhc29uOiBzdHJpbmcgfSkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3QoaDogSGFuZGxlcnMpIHtcbiAgLy8gSW4gZGV2LCBhc3N1bWUgc2VydmVyIG9uIHdzOi8vbG9jYWxob3N0OjMwMDFcbiAgY29uc3QgdXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfV1NfVVJMIHx8IFwid3M6Ly9sb2NhbGhvc3Q6MzAwMVwiO1xuICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQodXJsKTtcblxuICBjb25zdCBzZW5kID0gKG9iajogYW55KSA9PiB3cy5yZWFkeVN0YXRlID09PSB3cy5PUEVOICYmIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG5cbiAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgIGgub25PcGVuPy4oKTtcbiAgICAvLyBKb2luIGltbWVkaWF0ZWx5XG4gICAgc2VuZCh7IHByb3RvY29sX3ZlcnNpb246IFwiMVwiLCB0eXBlOiBcImpvaW4ucmVxdWVzdFwiLCBwYXlsb2FkOiB7fSB9KTtcbiAgfSk7XG4gIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCAoKSA9PiBoLm9uQ2xvc2U/LigpKTtcbiAgd3MuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZXYuZGF0YS50b1N0cmluZygpKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBtc2c/LnR5cGU7XG4gICAgICBjb25zdCBwYXlsb2FkID0gbXNnPy5wYXlsb2FkO1xuICAgICAgaWYgKHR5cGUgPT09IFwiam9pbi5hY2tcIikgaC5vbkpvaW5BY2s/LihwYXlsb2FkKTtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwic25hcHNob3QuZXZlbnRcIikgaC5vblNuYXBzaG90Py4ocGF5bG9hZCk7XG4gICAgICBlbHNlIGlmICh0eXBlID09PSBcInJ1blN0YXJ0LmV2ZW50XCIpIGgub25SdW5TdGFydD8uKHBheWxvYWQpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJydW5FbmQuZXZlbnRcIikgaC5vblJ1bkVuZD8uKHBheWxvYWQpO1xuICAgIH0gY2F0Y2gge31cbiAgfSk7XG5cbiAgY29uc3Qgb25GbGFwID0gKCkgPT4ge1xuICAgIHNlbmQoeyBwcm90b2NvbF92ZXJzaW9uOiBcIjFcIiwgdHlwZTogXCJpbnB1dC5mbGFwLnJlcXVlc3RcIiwgcGF5bG9hZDogeyBub25jZTogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMikgfSB9KTtcbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmbGFwXCIsIG9uRmxhcCBhcyBhbnkpO1xuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmbGFwXCIsIG9uRmxhcCBhcyBhbnkpO1xuICAgIHRyeSB7IHdzLmNsb3NlKCk7IH0gY2F0Y2gge31cbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJjb25uZWN0IiwiaCIsInVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19XU19VUkwiLCJ3cyIsIldlYlNvY2tldCIsInNlbmQiLCJvYmoiLCJyZWFkeVN0YXRlIiwiT1BFTiIsIkpTT04iLCJzdHJpbmdpZnkiLCJhZGRFdmVudExpc3RlbmVyIiwib25PcGVuIiwicHJvdG9jb2xfdmVyc2lvbiIsInR5cGUiLCJwYXlsb2FkIiwib25DbG9zZSIsImV2IiwibXNnIiwicGFyc2UiLCJkYXRhIiwidG9TdHJpbmciLCJvbkpvaW5BY2siLCJvblNuYXBzaG90Iiwib25SdW5TdGFydCIsIm9uUnVuRW5kIiwib25GbGFwIiwibm9uY2UiLCJNYXRoIiwicmFuZG9tIiwic2xpY2UiLCJ3aW5kb3ciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/net.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/track.ts":
/*!**********************!*\
  !*** ./lib/track.ts ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPipeSpacingPx: function() { return /* reexport safe */ _shared_track__WEBPACK_IMPORTED_MODULE_0__.getPipeSpacingPx; },\n/* harmony export */   getPipesAtTick: function() { return /* reexport safe */ _shared_track__WEBPACK_IMPORTED_MODULE_0__.getPipesAtTick; }\n/* harmony export */ });\n/* harmony import */ var _shared_track__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/track */ \"(app-pages-browser)/../shared/track.ts\");\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi90cmFjay50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3RyYWNrLnRzP2JhNWEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZ2V0UGlwZXNBdFRpY2ssIGdldFBpcGVTcGFjaW5nUHggfSBmcm9tIFwiLi4vLi4vc2hhcmVkL3RyYWNrXCI7XG4iXSwibmFtZXMiOlsiZ2V0UGlwZXNBdFRpY2siLCJnZXRQaXBlU3BhY2luZ1B4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/track.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/constants.ts":
/*!******************************!*\
  !*** ../shared/constants.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsConstants: function() { return /* binding */ PhysicsConstants; },\n/* harmony export */   RoomConfig: function() { return /* binding */ RoomConfig; },\n/* harmony export */   TrackConfig: function() { return /* binding */ TrackConfig; }\n/* harmony export */ });\n// Physics and gameplay constants (initial defaults; tuned in tests)\nconst PhysicsConstants = {\n    gravity: 620,\n    flapImpulse: -180,\n    forwardVelocity: 140,\n    hitbox: {\n        width: 24,\n        height: 18\n    }\n};\nconst TrackConfig = {\n    gapInitialRatio: 0.45,\n    gapTightenPer10s: 0.01,\n    gapMinRatio: 0.3,\n    spacingSeconds: 3.4,\n    // Extra initial horizontal space before the first pipe appears (in px)\n    initialOffsetPx: 75\n};\nconst RoomConfig = {\n    capacity: 32,\n    physicsHz: 60,\n    snapshotHz: 60\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvY29uc3RhbnRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG9FQUFvRTtBQUM3RCxNQUFNQSxtQkFBbUI7SUFDOUJDLFNBQVM7SUFDVEMsYUFBYSxDQUFDO0lBQ2RDLGlCQUFpQjtJQUNqQkMsUUFBUTtRQUFFQyxPQUFPO1FBQUlDLFFBQVE7SUFBRztBQUNsQyxFQUFXO0FBRUosTUFBTUMsY0FBYztJQUN6QkMsaUJBQWlCO0lBQ2pCQyxrQkFBa0I7SUFDbEJDLGFBQWE7SUFDYkMsZ0JBQWdCO0lBQ2hCLHVFQUF1RTtJQUN2RUMsaUJBQWlCO0FBQ25CLEVBQVc7QUFFSixNQUFNQyxhQUFhO0lBQ3hCQyxVQUFVO0lBQ1ZDLFdBQVc7SUFDWEMsWUFBWTtBQUNkLEVBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3NoYXJlZC9jb25zdGFudHMudHM/MjcyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQaHlzaWNzIGFuZCBnYW1lcGxheSBjb25zdGFudHMgKGluaXRpYWwgZGVmYXVsdHM7IHR1bmVkIGluIHRlc3RzKVxuZXhwb3J0IGNvbnN0IFBoeXNpY3NDb25zdGFudHMgPSB7XG4gIGdyYXZpdHk6IDYyMCwgLy8gcHgvc14yXG4gIGZsYXBJbXB1bHNlOiAtMTgwLCAvLyBweC9zIGFwcGxpZWQgdG8gdnlcbiAgZm9yd2FyZFZlbG9jaXR5OiAxNDAsIC8vIHB4L3MgYWxvbmcgeCBmb3IgZGlzdGFuY2UgY29tcHV0YXRpb25cbiAgaGl0Ym94OiB7IHdpZHRoOiAyNCwgaGVpZ2h0OiAxOCB9LFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFRyYWNrQ29uZmlnID0ge1xuICBnYXBJbml0aWFsUmF0aW86IDAuNDUsXG4gIGdhcFRpZ2h0ZW5QZXIxMHM6IDAuMDEsXG4gIGdhcE1pblJhdGlvOiAwLjMsXG4gIHNwYWNpbmdTZWNvbmRzOiAzLjQsXG4gIC8vIEV4dHJhIGluaXRpYWwgaG9yaXpvbnRhbCBzcGFjZSBiZWZvcmUgdGhlIGZpcnN0IHBpcGUgYXBwZWFycyAoaW4gcHgpXG4gIGluaXRpYWxPZmZzZXRQeDogNzUsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgUm9vbUNvbmZpZyA9IHtcbiAgY2FwYWNpdHk6IDMyLFxuICBwaHlzaWNzSHo6IDYwLFxuICBzbmFwc2hvdEh6OiA2MCxcbn0gYXMgY29uc3Q7XG4iXSwibmFtZXMiOlsiUGh5c2ljc0NvbnN0YW50cyIsImdyYXZpdHkiLCJmbGFwSW1wdWxzZSIsImZvcndhcmRWZWxvY2l0eSIsImhpdGJveCIsIndpZHRoIiwiaGVpZ2h0IiwiVHJhY2tDb25maWciLCJnYXBJbml0aWFsUmF0aW8iLCJnYXBUaWdodGVuUGVyMTBzIiwiZ2FwTWluUmF0aW8iLCJzcGFjaW5nU2Vjb25kcyIsImluaXRpYWxPZmZzZXRQeCIsIlJvb21Db25maWciLCJjYXBhY2l0eSIsInBoeXNpY3NIeiIsInNuYXBzaG90SHoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/constants.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/track.ts":
/*!**************************!*\
  !*** ../shared/track.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPipeSpacingPx: function() { return /* binding */ getPipeSpacingPx; },\n/* harmony export */   getPipesAtTick: function() { return /* binding */ getPipesAtTick; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-pages-browser)/../shared/constants.ts\");\n// NodeNext requires explicit .js extension for relative ESM imports at runtime.\n\nfunction xorshift32(seed) {\n    let x = seed | 0;\n    return ()=>{\n        x ^= x << 13;\n        x ^= x >>> 17;\n        x ^= x << 5;\n        // Convert to [0,1)\n        return (x >>> 0) / 0xffffffff;\n    };\n}\nfunction seedStringToInt(s) {\n    let h = 2166136261;\n    for(let i = 0; i < s.length; i++){\n        h ^= s.charCodeAt(i);\n        h = Math.imul(h, 16777619);\n    }\n    return h >>> 0;\n}\n// Deterministic track generator: returns visible pipes near the player's x based on tick\nfunction getPipesAtTick(seed, tick, opts) {\n    var _opts_worldHeight;\n    const H = (_opts_worldHeight = opts === null || opts === void 0 ? void 0 : opts.worldHeight) !== null && _opts_worldHeight !== void 0 ? _opts_worldHeight : 600;\n    const spacingS = _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.spacingSeconds;\n    const spacingPx = _constants_js__WEBPACK_IMPORTED_MODULE_0__.PhysicsConstants.forwardVelocity * spacingS;\n    const pipeWidth = 52;\n    // Determine how many pipes have been passed given tick and forward velocity\n    const time = tick / 60; // physics Hz for reference\n    const defaultDistance = time * _constants_js__WEBPACK_IMPORTED_MODULE_0__.PhysicsConstants.forwardVelocity;\n    var _opts_baseDistance;\n    const distance = (_opts_baseDistance = opts === null || opts === void 0 ? void 0 : opts.baseDistance) !== null && _opts_baseDistance !== void 0 ? _opts_baseDistance : defaultDistance;\n    // Choose index near the pipe whose left edge is at/just ahead of the player's distance.\n    // World index i defines x position: x(i) = (i + 1) * spacingPx + initialOffsetPx\n    // so i ≈ (distance - initialOffsetPx) / spacingPx - 1.\n    //\n    // IMPORTANT: We decouple the procedural \"generation index\" (g) from the world index (i)\n    // so that adding initialOffsetPx creates empty runway without advancing the RNG sequence\n    // or the difficulty schedule. Concretely, g = i - baseAtZero, where baseAtZero is the\n    // world index computed at distance = 0. This makes g start at 0 near the origin and\n    // progress independently of the initial horizontal offset.\n    const pipeIndexBase = Math.floor((distance - _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.initialOffsetPx) / spacingPx) - 1;\n    const baseAtZero = Math.floor((0 - _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.initialOffsetPx) / spacingPx) - 1; // index when distance = 0\n    // Create RNG seeded by seed + index to get stable per-pipe variations\n    const baseSeed = seedStringToInt(seed);\n    const results = [];\n    var _opts_countBefore;\n    const before = Math.max(0, Math.floor((_opts_countBefore = opts === null || opts === void 0 ? void 0 : opts.countBefore) !== null && _opts_countBefore !== void 0 ? _opts_countBefore : 0));\n    var _opts_countAfter;\n    const after = Math.max(1, Math.floor((_opts_countAfter = opts === null || opts === void 0 ? void 0 : opts.countAfter) !== null && _opts_countAfter !== void 0 ? _opts_countAfter : 3));\n    const start = Math.max(0, pipeIndexBase - before);\n    // Guarantee we produce some pipes even if the base index is negative (pre-runway)\n    const end = Math.max(start + after, pipeIndexBase + after); // exclusive upper bound\n    for(let i = start; i < end; i++){\n        const g = i; // generation index starts at 0 for the first real pipe\n        const rng = xorshift32(baseSeed ^ g * 0x9e3779b1);\n        // Gap tightening over time is based on generation index\n        const seconds = Math.max(0, g * spacingS);\n        let gapRatio = _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.gapInitialRatio - _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.gapTightenPer10s * (seconds / 10);\n        gapRatio = Math.max(_constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.gapMinRatio, gapRatio);\n        const gapHeight = H * gapRatio;\n        // Gap center jitter within bounds [gapHeight/2, H - gapHeight/2]\n        const minCenter = gapHeight / 2 + 10;\n        const maxCenter = H - gapHeight / 2 - 10;\n        const gapCenterY = minCenter + (maxCenter - minCenter) * rng();\n        const x = (i + 1) * spacingPx + _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.initialOffsetPx; // ahead of origin with configurable offset\n        results.push({\n            x,\n            gapCenterY,\n            gapHeight,\n            width: pipeWidth\n        });\n    }\n    return results;\n}\n// Helper for consumers to know the horizontal spacing between pipe columns in px\nfunction getPipeSpacingPx() {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.PhysicsConstants.forwardVelocity * _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.spacingSeconds;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvdHJhY2sudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0ZBQWdGO0FBQ2pCO0FBUy9ELFNBQVNFLFdBQVdDLElBQVk7SUFDOUIsSUFBSUMsSUFBSUQsT0FBTztJQUNmLE9BQU87UUFDTEMsS0FBS0EsS0FBSztRQUNWQSxLQUFLQSxNQUFNO1FBQ1hBLEtBQUtBLEtBQUs7UUFDVixtQkFBbUI7UUFDbkIsT0FBTyxDQUFDQSxNQUFNLEtBQUs7SUFDckI7QUFDRjtBQUVBLFNBQVNDLGdCQUFnQkMsQ0FBUztJQUNoQyxJQUFJQyxJQUFJO0lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLEVBQUVHLE1BQU0sRUFBRUQsSUFBSztRQUNqQ0QsS0FBS0QsRUFBRUksVUFBVSxDQUFDRjtRQUNsQkQsSUFBSUksS0FBS0MsSUFBSSxDQUFDTCxHQUFHO0lBQ25CO0lBQ0EsT0FBT0EsTUFBTTtBQUNmO0FBRUEseUZBQXlGO0FBQ2xGLFNBQVNNLGVBQ2RWLElBQVksRUFDWlcsSUFBWSxFQUNaQyxJQUFpRztRQUV2RkE7SUFBVixNQUFNQyxJQUFJRCxDQUFBQSxvQkFBQUEsaUJBQUFBLDJCQUFBQSxLQUFNRSxXQUFXLGNBQWpCRiwrQkFBQUEsb0JBQXFCO0lBQy9CLE1BQU1HLFdBQVdsQixzREFBV0EsQ0FBQ21CLGNBQWM7SUFDM0MsTUFBTUMsWUFBWW5CLDJEQUFnQkEsQ0FBQ29CLGVBQWUsR0FBR0g7SUFDckQsTUFBTUksWUFBWTtJQUVsQiw0RUFBNEU7SUFDNUUsTUFBTUMsT0FBT1QsT0FBTyxJQUFJLDJCQUEyQjtJQUNuRCxNQUFNVSxrQkFBa0JELE9BQU90QiwyREFBZ0JBLENBQUNvQixlQUFlO1FBQzlDTjtJQUFqQixNQUFNVSxXQUFXVixDQUFBQSxxQkFBQUEsaUJBQUFBLDJCQUFBQSxLQUFNVyxZQUFZLGNBQWxCWCxnQ0FBQUEscUJBQXNCUztJQUN2Qyx3RkFBd0Y7SUFDeEYsaUZBQWlGO0lBQ2pGLHVEQUF1RDtJQUN2RCxFQUFFO0lBQ0Ysd0ZBQXdGO0lBQ3hGLHlGQUF5RjtJQUN6RixzRkFBc0Y7SUFDdEYsb0ZBQW9GO0lBQ3BGLDJEQUEyRDtJQUMzRCxNQUFNRyxnQkFBZ0JoQixLQUFLaUIsS0FBSyxDQUFDLENBQUNILFdBQVd6QixzREFBV0EsQ0FBQzZCLGVBQWUsSUFBSVQsYUFBYTtJQUN6RixNQUFNVSxhQUFhbkIsS0FBS2lCLEtBQUssQ0FBQyxDQUFDLElBQUk1QixzREFBV0EsQ0FBQzZCLGVBQWUsSUFBSVQsYUFBYSxHQUFHLDBCQUEwQjtJQUU1RyxzRUFBc0U7SUFDdEUsTUFBTVcsV0FBVzFCLGdCQUFnQkY7SUFFakMsTUFBTTZCLFVBQXNCLEVBQUU7UUFDUWpCO0lBQXRDLE1BQU1rQixTQUFTdEIsS0FBS3VCLEdBQUcsQ0FBQyxHQUFHdkIsS0FBS2lCLEtBQUssQ0FBQ2IsQ0FBQUEsb0JBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTW9CLFdBQVcsY0FBakJwQiwrQkFBQUEsb0JBQXFCO1FBQ3RCQTtJQUFyQyxNQUFNcUIsUUFBUXpCLEtBQUt1QixHQUFHLENBQUMsR0FBR3ZCLEtBQUtpQixLQUFLLENBQUNiLENBQUFBLG1CQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1zQixVQUFVLGNBQWhCdEIsOEJBQUFBLG1CQUFvQjtJQUN6RCxNQUFNdUIsUUFBUTNCLEtBQUt1QixHQUFHLENBQUMsR0FBR1AsZ0JBQWdCTTtJQUMxQyxrRkFBa0Y7SUFDbEYsTUFBTU0sTUFBTTVCLEtBQUt1QixHQUFHLENBQUNJLFFBQVFGLE9BQU9ULGdCQUFnQlMsUUFBUSx3QkFBd0I7SUFDcEYsSUFBSyxJQUFJNUIsSUFBSThCLE9BQU85QixJQUFJK0IsS0FBSy9CLElBQUs7UUFDaEMsTUFBTWdDLElBQUloQyxHQUFHLHVEQUF1RDtRQUNwRSxNQUFNaUMsTUFBTXZDLFdBQVc2QixXQUFZUyxJQUFJO1FBRXZDLHdEQUF3RDtRQUN4RCxNQUFNRSxVQUFVL0IsS0FBS3VCLEdBQUcsQ0FBQyxHQUFHTSxJQUFJdEI7UUFDaEMsSUFBSXlCLFdBQ0YzQyxzREFBV0EsQ0FBQzRDLGVBQWUsR0FDM0I1QyxzREFBV0EsQ0FBQzZDLGdCQUFnQixHQUFJSCxDQUFBQSxVQUFVLEVBQUM7UUFDN0NDLFdBQVdoQyxLQUFLdUIsR0FBRyxDQUFDbEMsc0RBQVdBLENBQUM4QyxXQUFXLEVBQUVIO1FBQzdDLE1BQU1JLFlBQVkvQixJQUFJMkI7UUFFdEIsaUVBQWlFO1FBQ2pFLE1BQU1LLFlBQVlELFlBQVksSUFBSTtRQUNsQyxNQUFNRSxZQUFZakMsSUFBSStCLFlBQVksSUFBSTtRQUN0QyxNQUFNRyxhQUFhRixZQUFZLENBQUNDLFlBQVlELFNBQVEsSUFBS1A7UUFFM0QsTUFBTXJDLElBQUksQ0FBQ0ksSUFBSSxLQUFLWSxZQUFZcEIsc0RBQVdBLENBQUM2QixlQUFlLEVBQUUsMkNBQTJDO1FBRXRHRyxRQUFRbUIsSUFBSSxDQUFDO1lBQUUvQztZQUFHOEM7WUFBWUg7WUFBV0ssT0FBTzlCO1FBQVU7SUFDNUQ7SUFDQSxPQUFPVTtBQUNUO0FBRUEsaUZBQWlGO0FBQzFFLFNBQVNxQjtJQUNkLE9BQU9wRCwyREFBZ0JBLENBQUNvQixlQUFlLEdBQUdyQixzREFBV0EsQ0FBQ21CLGNBQWM7QUFDdEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3NoYXJlZC90cmFjay50cz9kODkyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5vZGVOZXh0IHJlcXVpcmVzIGV4cGxpY2l0IC5qcyBleHRlbnNpb24gZm9yIHJlbGF0aXZlIEVTTSBpbXBvcnRzIGF0IHJ1bnRpbWUuXG5pbXBvcnQgeyBUcmFja0NvbmZpZywgUGh5c2ljc0NvbnN0YW50cyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBpcGVTcGVjIHtcbiAgeDogbnVtYmVyOyAvLyBsZWZ0IHggb2YgcGlwZSBwYWlyXG4gIGdhcENlbnRlclk6IG51bWJlcjtcbiAgZ2FwSGVpZ2h0OiBudW1iZXI7XG4gIHdpZHRoOiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIHhvcnNoaWZ0MzIoc2VlZDogbnVtYmVyKSB7XG4gIGxldCB4ID0gc2VlZCB8IDA7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgeCBePSB4IDw8IDEzO1xuICAgIHggXj0geCA+Pj4gMTc7XG4gICAgeCBePSB4IDw8IDU7XG4gICAgLy8gQ29udmVydCB0byBbMCwxKVxuICAgIHJldHVybiAoeCA+Pj4gMCkgLyAweGZmZmZmZmZmO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWVkU3RyaW5nVG9JbnQoczogc3RyaW5nKTogbnVtYmVyIHtcbiAgbGV0IGggPSAyMTY2MTM2MjYxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICBoIF49IHMuY2hhckNvZGVBdChpKTtcbiAgICBoID0gTWF0aC5pbXVsKGgsIDE2Nzc3NjE5KTtcbiAgfVxuICByZXR1cm4gaCA+Pj4gMDtcbn1cblxuLy8gRGV0ZXJtaW5pc3RpYyB0cmFjayBnZW5lcmF0b3I6IHJldHVybnMgdmlzaWJsZSBwaXBlcyBuZWFyIHRoZSBwbGF5ZXIncyB4IGJhc2VkIG9uIHRpY2tcbmV4cG9ydCBmdW5jdGlvbiBnZXRQaXBlc0F0VGljayhcbiAgc2VlZDogc3RyaW5nLFxuICB0aWNrOiBudW1iZXIsXG4gIG9wdHM/OiB7IHdvcmxkSGVpZ2h0PzogbnVtYmVyOyBjb3VudEJlZm9yZT86IG51bWJlcjsgY291bnRBZnRlcj86IG51bWJlcjsgYmFzZURpc3RhbmNlPzogbnVtYmVyIH0sXG4pOiBQaXBlU3BlY1tdIHtcbiAgY29uc3QgSCA9IG9wdHM/LndvcmxkSGVpZ2h0ID8/IDYwMDtcbiAgY29uc3Qgc3BhY2luZ1MgPSBUcmFja0NvbmZpZy5zcGFjaW5nU2Vjb25kcztcbiAgY29uc3Qgc3BhY2luZ1B4ID0gUGh5c2ljc0NvbnN0YW50cy5mb3J3YXJkVmVsb2NpdHkgKiBzcGFjaW5nUztcbiAgY29uc3QgcGlwZVdpZHRoID0gNTI7XG5cbiAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IHBpcGVzIGhhdmUgYmVlbiBwYXNzZWQgZ2l2ZW4gdGljayBhbmQgZm9yd2FyZCB2ZWxvY2l0eVxuICBjb25zdCB0aW1lID0gdGljayAvIDYwOyAvLyBwaHlzaWNzIEh6IGZvciByZWZlcmVuY2VcbiAgY29uc3QgZGVmYXVsdERpc3RhbmNlID0gdGltZSAqIFBoeXNpY3NDb25zdGFudHMuZm9yd2FyZFZlbG9jaXR5O1xuICBjb25zdCBkaXN0YW5jZSA9IG9wdHM/LmJhc2VEaXN0YW5jZSA/PyBkZWZhdWx0RGlzdGFuY2U7XG4gIC8vIENob29zZSBpbmRleCBuZWFyIHRoZSBwaXBlIHdob3NlIGxlZnQgZWRnZSBpcyBhdC9qdXN0IGFoZWFkIG9mIHRoZSBwbGF5ZXIncyBkaXN0YW5jZS5cbiAgLy8gV29ybGQgaW5kZXggaSBkZWZpbmVzIHggcG9zaXRpb246IHgoaSkgPSAoaSArIDEpICogc3BhY2luZ1B4ICsgaW5pdGlhbE9mZnNldFB4XG4gIC8vIHNvIGkg4omIIChkaXN0YW5jZSAtIGluaXRpYWxPZmZzZXRQeCkgLyBzcGFjaW5nUHggLSAxLlxuICAvL1xuICAvLyBJTVBPUlRBTlQ6IFdlIGRlY291cGxlIHRoZSBwcm9jZWR1cmFsIFwiZ2VuZXJhdGlvbiBpbmRleFwiIChnKSBmcm9tIHRoZSB3b3JsZCBpbmRleCAoaSlcbiAgLy8gc28gdGhhdCBhZGRpbmcgaW5pdGlhbE9mZnNldFB4IGNyZWF0ZXMgZW1wdHkgcnVud2F5IHdpdGhvdXQgYWR2YW5jaW5nIHRoZSBSTkcgc2VxdWVuY2VcbiAgLy8gb3IgdGhlIGRpZmZpY3VsdHkgc2NoZWR1bGUuIENvbmNyZXRlbHksIGcgPSBpIC0gYmFzZUF0WmVybywgd2hlcmUgYmFzZUF0WmVybyBpcyB0aGVcbiAgLy8gd29ybGQgaW5kZXggY29tcHV0ZWQgYXQgZGlzdGFuY2UgPSAwLiBUaGlzIG1ha2VzIGcgc3RhcnQgYXQgMCBuZWFyIHRoZSBvcmlnaW4gYW5kXG4gIC8vIHByb2dyZXNzIGluZGVwZW5kZW50bHkgb2YgdGhlIGluaXRpYWwgaG9yaXpvbnRhbCBvZmZzZXQuXG4gIGNvbnN0IHBpcGVJbmRleEJhc2UgPSBNYXRoLmZsb29yKChkaXN0YW5jZSAtIFRyYWNrQ29uZmlnLmluaXRpYWxPZmZzZXRQeCkgLyBzcGFjaW5nUHgpIC0gMTtcbiAgY29uc3QgYmFzZUF0WmVybyA9IE1hdGguZmxvb3IoKDAgLSBUcmFja0NvbmZpZy5pbml0aWFsT2Zmc2V0UHgpIC8gc3BhY2luZ1B4KSAtIDE7IC8vIGluZGV4IHdoZW4gZGlzdGFuY2UgPSAwXG5cbiAgLy8gQ3JlYXRlIFJORyBzZWVkZWQgYnkgc2VlZCArIGluZGV4IHRvIGdldCBzdGFibGUgcGVyLXBpcGUgdmFyaWF0aW9uc1xuICBjb25zdCBiYXNlU2VlZCA9IHNlZWRTdHJpbmdUb0ludChzZWVkKTtcblxuICBjb25zdCByZXN1bHRzOiBQaXBlU3BlY1tdID0gW107XG4gIGNvbnN0IGJlZm9yZSA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3Iob3B0cz8uY291bnRCZWZvcmUgPz8gMCkpO1xuICBjb25zdCBhZnRlciA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3Iob3B0cz8uY291bnRBZnRlciA/PyAzKSk7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgcGlwZUluZGV4QmFzZSAtIGJlZm9yZSk7XG4gIC8vIEd1YXJhbnRlZSB3ZSBwcm9kdWNlIHNvbWUgcGlwZXMgZXZlbiBpZiB0aGUgYmFzZSBpbmRleCBpcyBuZWdhdGl2ZSAocHJlLXJ1bndheSlcbiAgY29uc3QgZW5kID0gTWF0aC5tYXgoc3RhcnQgKyBhZnRlciwgcGlwZUluZGV4QmFzZSArIGFmdGVyKTsgLy8gZXhjbHVzaXZlIHVwcGVyIGJvdW5kXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY29uc3QgZyA9IGk7IC8vIGdlbmVyYXRpb24gaW5kZXggc3RhcnRzIGF0IDAgZm9yIHRoZSBmaXJzdCByZWFsIHBpcGVcbiAgICBjb25zdCBybmcgPSB4b3JzaGlmdDMyKGJhc2VTZWVkIF4gKGcgKiAweDllMzc3OWIxKSk7XG5cbiAgICAvLyBHYXAgdGlnaHRlbmluZyBvdmVyIHRpbWUgaXMgYmFzZWQgb24gZ2VuZXJhdGlvbiBpbmRleFxuICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLm1heCgwLCBnICogc3BhY2luZ1MpO1xuICAgIGxldCBnYXBSYXRpbyA9XG4gICAgICBUcmFja0NvbmZpZy5nYXBJbml0aWFsUmF0aW8gLVxuICAgICAgVHJhY2tDb25maWcuZ2FwVGlnaHRlblBlcjEwcyAqIChzZWNvbmRzIC8gMTApO1xuICAgIGdhcFJhdGlvID0gTWF0aC5tYXgoVHJhY2tDb25maWcuZ2FwTWluUmF0aW8sIGdhcFJhdGlvKTtcbiAgICBjb25zdCBnYXBIZWlnaHQgPSBIICogZ2FwUmF0aW87XG5cbiAgICAvLyBHYXAgY2VudGVyIGppdHRlciB3aXRoaW4gYm91bmRzIFtnYXBIZWlnaHQvMiwgSCAtIGdhcEhlaWdodC8yXVxuICAgIGNvbnN0IG1pbkNlbnRlciA9IGdhcEhlaWdodCAvIDIgKyAxMDtcbiAgICBjb25zdCBtYXhDZW50ZXIgPSBIIC0gZ2FwSGVpZ2h0IC8gMiAtIDEwO1xuICAgIGNvbnN0IGdhcENlbnRlclkgPSBtaW5DZW50ZXIgKyAobWF4Q2VudGVyIC0gbWluQ2VudGVyKSAqIHJuZygpO1xuXG4gIGNvbnN0IHggPSAoaSArIDEpICogc3BhY2luZ1B4ICsgVHJhY2tDb25maWcuaW5pdGlhbE9mZnNldFB4OyAvLyBhaGVhZCBvZiBvcmlnaW4gd2l0aCBjb25maWd1cmFibGUgb2Zmc2V0XG5cbiAgICByZXN1bHRzLnB1c2goeyB4LCBnYXBDZW50ZXJZLCBnYXBIZWlnaHQsIHdpZHRoOiBwaXBlV2lkdGggfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8vIEhlbHBlciBmb3IgY29uc3VtZXJzIHRvIGtub3cgdGhlIGhvcml6b250YWwgc3BhY2luZyBiZXR3ZWVuIHBpcGUgY29sdW1ucyBpbiBweFxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpcGVTcGFjaW5nUHgoKSB7XG4gIHJldHVybiBQaHlzaWNzQ29uc3RhbnRzLmZvcndhcmRWZWxvY2l0eSAqIFRyYWNrQ29uZmlnLnNwYWNpbmdTZWNvbmRzO1xufVxuIl0sIm5hbWVzIjpbIlRyYWNrQ29uZmlnIiwiUGh5c2ljc0NvbnN0YW50cyIsInhvcnNoaWZ0MzIiLCJzZWVkIiwieCIsInNlZWRTdHJpbmdUb0ludCIsInMiLCJoIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJNYXRoIiwiaW11bCIsImdldFBpcGVzQXRUaWNrIiwidGljayIsIm9wdHMiLCJIIiwid29ybGRIZWlnaHQiLCJzcGFjaW5nUyIsInNwYWNpbmdTZWNvbmRzIiwic3BhY2luZ1B4IiwiZm9yd2FyZFZlbG9jaXR5IiwicGlwZVdpZHRoIiwidGltZSIsImRlZmF1bHREaXN0YW5jZSIsImRpc3RhbmNlIiwiYmFzZURpc3RhbmNlIiwicGlwZUluZGV4QmFzZSIsImZsb29yIiwiaW5pdGlhbE9mZnNldFB4IiwiYmFzZUF0WmVybyIsImJhc2VTZWVkIiwicmVzdWx0cyIsImJlZm9yZSIsIm1heCIsImNvdW50QmVmb3JlIiwiYWZ0ZXIiLCJjb3VudEFmdGVyIiwic3RhcnQiLCJlbmQiLCJnIiwicm5nIiwic2Vjb25kcyIsImdhcFJhdGlvIiwiZ2FwSW5pdGlhbFJhdGlvIiwiZ2FwVGlnaHRlblBlcjEwcyIsImdhcE1pblJhdGlvIiwiZ2FwSGVpZ2h0IiwibWluQ2VudGVyIiwibWF4Q2VudGVyIiwiZ2FwQ2VudGVyWSIsInB1c2giLCJ3aWR0aCIsImdldFBpcGVTcGFjaW5nUHgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/track.ts\n"));

/***/ })

}]);