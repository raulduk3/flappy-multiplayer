"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_components_GameCanvas_tsx"],{

/***/ "(app-pages-browser)/./components/GameCanvas.tsx":
/*!***********************************!*\
  !*** ./components/GameCanvas.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ GameCanvas; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_track__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/track */ \"(app-pages-browser)/./lib/track.ts\");\n/* harmony import */ var _lib_net__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/net */ \"(app-pages-browser)/./lib/net.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction GameCanvas(param) {\n    let { width, height } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [seed, setSeed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [tick, setTick] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [players, setPlayers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [localRunId, setLocalRunId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const cleanup = (0,_lib_net__WEBPACK_IMPORTED_MODULE_3__.connect)({\n            onOpen: ()=>setConnected(true),\n            onClose: ()=>setConnected(false),\n            onJoinAck: (payload)=>setSeed(payload.seed),\n            onSnapshot: (payload)=>{\n                setSeed(payload.seed);\n                setTick(payload.tick);\n                setPlayers(payload.players);\n            },\n            onRunStart: (payload)=>{\n                setLocalRunId(payload.run_id);\n            },\n            onRunEnd: ()=>{\n                // Reset local run so camera snaps back to start and doesn't follow others\n                setLocalRunId(null);\n            }\n        });\n        const onKey = (e)=>{\n            if (e.code === \"Space\") {\n                e.preventDefault();\n                window.dispatchEvent(new CustomEvent(\"flap\"));\n            }\n        };\n        window.addEventListener(\"keydown\", onKey);\n        const onTap = ()=>window.dispatchEvent(new CustomEvent(\"flap\"));\n        window.addEventListener(\"click\", onTap);\n        return ()=>{\n            window.removeEventListener(\"keydown\", onKey);\n            window.removeEventListener(\"click\", onTap);\n            cleanup === null || cleanup === void 0 ? void 0 : cleanup();\n        };\n    }, []);\n    // Derive the local player entity for the active run if known (by run_id)\n    const localPlayer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!localRunId) return undefined;\n        return players.find((p)=>p.run_id === localRunId);\n    }, [\n        players,\n        localRunId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let raf = 0;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));\n        // Resize backing store for crisp rendering\n        canvas.width = Math.floor(width * dpr);\n        canvas.height = Math.floor(height * dpr);\n        canvas.style.width = \"\".concat(width, \"px\");\n        canvas.style.height = \"\".concat(height, \"px\");\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        const render = ()=>{\n            ctx.clearRect(0, 0, width, height);\n            // Background\n            ctx.fillStyle = \"#0e1520\";\n            ctx.fillRect(0, 0, width, height);\n            // World scaling to match server-side WORLD_HEIGHT\n            const WORLD_H = 600;\n            const sY = height / WORLD_H;\n            // Camera: anchor only to local player's distance; otherwise stay at origin (don't follow others)\n            const LEAD_IN = 160; // pixels of space ahead of player on the left side\n            const camX = localPlayer ? localPlayer.distance : 0;\n            // Determine how many pipes to render so they fill the screen width\n            const spacingPx = (0,_lib_track__WEBPACK_IMPORTED_MODULE_2__.getPipeSpacingPx)();\n            const countAfter = Math.ceil((width + LEAD_IN) / spacingPx) + 2;\n            const countBefore = 3; // a bit more history so pipes don't drop too early\n            if (seed) {\n                const pipes = (0,_lib_track__WEBPACK_IMPORTED_MODULE_2__.getPipesAtTick)(seed, tick, {\n                    worldHeight: WORLD_H,\n                    countBefore,\n                    countAfter,\n                    baseDistance: camX\n                });\n                for (const p of pipes){\n                    const screenX = Math.round(LEAD_IN + (p.x - camX));\n                    // Cull if completely off screen (non-strict to avoid early pop)\n                    if (screenX + p.width <= 0 || screenX >= width) continue;\n                    const topH = (p.gapCenterY - p.gapHeight / 2) * sY;\n                    const botY = (p.gapCenterY + p.gapHeight / 2) * sY;\n                    ctx.fillStyle = \"#22c55e\";\n                    ctx.fillRect(screenX, 0, p.width, topH);\n                    ctx.fillRect(screenX, botY, p.width, height - botY);\n                }\n            }\n            // Draw players relative to camera\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"bottom\";\n            const labelPx = Math.max(10, Math.round(12 * (height / 600)));\n            ctx.font = \"\".concat(labelPx, \"px system-ui\");\n            for (const pl of players){\n                const x = Math.round(LEAD_IN + (pl.distance - camX));\n                const y = pl.position.y * (height / 600);\n                // Avatar\n                const isLocal = localPlayer && pl.run_id === localPlayer.run_id;\n                ctx.fillStyle = isLocal ? \"#fbbf24\" : \"#60a5fa\";\n                const aw = Math.max(16, Math.round(24 * (height / 600)));\n                const ah = Math.max(12, Math.round(18 * (height / 600)));\n                ctx.fillRect(x, y, aw, ah);\n                // Label above avatar\n                const label = (pl.player_id || \"?\").slice(0, 6);\n                ctx.fillStyle = \"#e5e7eb\";\n                ctx.fillText(label, x + Math.round(aw / 2), y - 4);\n            }\n            // If we don't yet have a local player from snapshots, render a placeholder\n            if (!localPlayer) {\n                const aw = Math.max(16, Math.round(24 * (height / 600)));\n                const ah = Math.max(12, Math.round(18 * (height / 600)));\n                const x = Math.round(LEAD_IN);\n                const y = Math.round(WORLD_H * 0.4 * sY);\n                ctx.fillStyle = \"#fbbf24\"; // highlight color for local placeholder\n                ctx.fillRect(x, y, aw, ah);\n                ctx.fillStyle = \"#e5e7eb\";\n                ctx.fillText(\"You\", x + Math.round(aw / 2), y - 4);\n            }\n            // HUD (render last to ensure it's on top)\n            const status = connected ? \"Connected\" : \"Connecting...\";\n            const hudLines = [\n                status\n            ];\n            const me = localPlayer;\n            if (me) {\n                const dist = Math.max(0, Math.floor(me.distance));\n                var _me_score;\n                const score = (_me_score = me.score) !== null && _me_score !== void 0 ? _me_score : 0;\n                hudLines.push(\"Score: \".concat(score));\n                hudLines.push(\"Dist: \".concat(dist, \"px\"));\n            }\n            const lineH = 18;\n            const pad = 8;\n            const hudW = 160;\n            const hudH = hudLines.length * lineH + pad * 2 - 4;\n            // backdrop for readability\n            ctx.fillStyle = \"rgba(2,6,23,0.6)\";\n            ctx.fillRect(8, 8, hudW, hudH);\n            ctx.fillStyle = \"#cbd5e1\";\n            ctx.font = \"14px system-ui\";\n            ctx.textBaseline = \"top\";\n            ctx.textAlign = \"left\";\n            let yOff = 8 + pad - 2;\n            for (const line of hudLines){\n                ctx.fillText(line, 12, yOff);\n                yOff += lineH;\n            }\n            raf = requestAnimationFrame(render);\n        };\n        raf = requestAnimationFrame(render);\n        return ()=>cancelAnimationFrame(raf);\n    }, [\n        width,\n        height,\n        seed,\n        tick,\n        players,\n        connected,\n        localRunId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        width: width,\n        height: height\n    }, void 0, false, {\n        fileName: \"/Users/richardalvarez/Dev/flappy-multiplayer/src/client/components/GameCanvas.tsx\",\n        lineNumber: 167,\n        columnNumber: 10\n    }, this);\n}\n_s(GameCanvas, \"Y8NLWKkLGYpCYHqDnL7BnUxkRo0=\");\n_c = GameCanvas;\nvar _c;\n$RefreshReg$(_c, \"GameCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvR2FtZUNhbnZhcy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDNkQ7QUFDRztBQUUzQjtBQUl0QixTQUFTTyxXQUFXLEtBQXdCO1FBQXhCLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFTLEdBQXhCOztJQUNqQyxNQUFNQyxZQUFZUiw2Q0FBTUEsQ0FBMkI7SUFDbkQsTUFBTSxDQUFDUyxXQUFXQyxhQUFhLEdBQUdULCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ1UsTUFBTUMsUUFBUSxHQUFHWCwrQ0FBUUEsQ0FBZ0I7SUFDaEQsTUFBTSxDQUFDWSxNQUFNQyxRQUFRLEdBQUdiLCtDQUFRQSxDQUFDO0lBQ2pDLE1BQU0sQ0FBQ2MsU0FBU0MsV0FBVyxHQUFHZiwrQ0FBUUEsQ0FBc0IsRUFBRTtJQUM5RCxNQUFNLENBQUNnQixZQUFZQyxjQUFjLEdBQUdqQiwrQ0FBUUEsQ0FBZ0I7SUFFNURILGdEQUFTQSxDQUFDO1FBQ1IsTUFBTXFCLFVBQVVmLGlEQUFPQSxDQUFDO1lBQ3RCZ0IsUUFBUSxJQUFNVixhQUFhO1lBQzNCVyxTQUFTLElBQU1YLGFBQWE7WUFDNUJZLFdBQVcsQ0FBQ0MsVUFBK0NYLFFBQVFXLFFBQVFaLElBQUk7WUFDL0VhLFlBQVksQ0FBQ0Q7Z0JBQ1hYLFFBQVFXLFFBQVFaLElBQUk7Z0JBQ3BCRyxRQUFRUyxRQUFRVixJQUFJO2dCQUNwQkcsV0FBV08sUUFBUVIsT0FBTztZQUM1QjtZQUNBVSxZQUFZLENBQUNGO2dCQUNYTCxjQUFjSyxRQUFRRyxNQUFNO1lBQzlCO1lBQ0FDLFVBQVU7Z0JBQ1IsMEVBQTBFO2dCQUMxRVQsY0FBYztZQUNoQjtRQUNGO1FBQ0EsTUFBTVUsUUFBUSxDQUFDQztZQUNiLElBQUlBLEVBQUVDLElBQUksS0FBSyxTQUFTO2dCQUN0QkQsRUFBRUUsY0FBYztnQkFDaEJDLE9BQU9DLGFBQWEsQ0FBQyxJQUFJQyxZQUFZO1lBQ3ZDO1FBQ0Y7UUFDQUYs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LElBQUk7WUFDakQsMkJBQTJCO1lBQzNCL0MsSUFBSUssU0FBUyxHQUFHO1lBQ2hCTCxJQUFJTSxRQUFRLENBQUMsR0FBRyxHQUFHMEMsTUFBTUM7WUFDekJqRCxJQUFJSyxTQUFTLEdBQUc7WUFDaEJMLElBQUk2QixJQUFJLEdBQUc7WUFDWDdCLElBQUkyQixZQUFZLEdBQUc7WUFDbkIzQixJQUFJMEIsU0FBUyxHQUFHO1lBQ2hCLElBQUl5QixPQUFPLElBQUlKLE1BQU07WUFDckIsS0FBSyxNQUFNSyxRQUFRWCxTQUFVO2dCQUMzQnpDLElBQUl1QyxRQUFRLENBQUNhLE1BQU0sSUFBSUQ7Z0JBQ3ZCQSxRQUFRTDtZQUNWO1lBRUF2RCxNQUFNOEQsc0JBQXNCbEQ7UUFDOUI7UUFDQVosTUFBTThELHNCQUFzQmxEO1FBQzVCLE9BQU8sSUFBTW1ELHFCQUFxQi9EO0lBQ3BDLEdBQUc7UUFBQ3BDO1FBQU9DO1FBQVFJO1FBQU1FO1FBQU1FO1FBQVNOO1FBQVdRO0tBQVc7SUFFOUQscUJBQU8sOERBQUMwQjtRQUFPK0QsS0FBS2xHO1FBQVdGLE9BQU9BO1FBQU9DLFFBQVFBOzs7Ozs7QUFDdkQ7R0EvSndCRjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0dhbWVDYW52YXMudHN4PzUyNmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGdldFBpcGVzQXRUaWNrLCBnZXRQaXBlU3BhY2luZ1B4IH0gZnJvbSBcIi4uL2xpYi90cmFja1wiO1xuaW1wb3J0IHR5cGUgeyBBY3RpdmVQbGF5ZXJTdGF0ZSwgU25hcHNob3RQYXlsb2FkIH0gZnJvbSBcIi4uLy4uL3NoYXJlZC90eXBlc1wiO1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gXCIuLi9saWIvbmV0XCI7XG5cbnR5cGUgUHJvcHMgPSB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdhbWVDYW52YXMoeyB3aWR0aCwgaGVpZ2h0IH06IFByb3BzKSB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY29ubmVjdGVkLCBzZXRDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2VlZCwgc2V0U2VlZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3RpY2ssIHNldFRpY2tdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtwbGF5ZXJzLCBzZXRQbGF5ZXJzXSA9IHVzZVN0YXRlPEFjdGl2ZVBsYXllclN0YXRlW10+KFtdKTtcbiAgY29uc3QgW2xvY2FsUnVuSWQsIHNldExvY2FsUnVuSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwID0gY29ubmVjdCh7XG4gICAgICBvbk9wZW46ICgpID0+IHNldENvbm5lY3RlZCh0cnVlKSxcbiAgICAgIG9uQ2xvc2U6ICgpID0+IHNldENvbm5lY3RlZChmYWxzZSksXG4gICAgICBvbkpvaW5BY2s6IChwYXlsb2FkOiB7IHJvb21faWQ6IHN0cmluZzsgc2VlZDogc3RyaW5nIH0pID0+IHNldFNlZWQocGF5bG9hZC5zZWVkKSxcbiAgICAgIG9uU25hcHNob3Q6IChwYXlsb2FkOiBTbmFwc2hvdFBheWxvYWQpID0+IHtcbiAgICAgICAgc2V0U2VlZChwYXlsb2FkLnNlZWQpO1xuICAgICAgICBzZXRUaWNrKHBheWxvYWQudGljayk7XG4gICAgICAgIHNldFBsYXllcnMocGF5bG9hZC5wbGF5ZXJzKTtcbiAgICAgIH0sXG4gICAgICBvblJ1blN0YXJ0OiAocGF5bG9hZDogeyByb29tX2lkOiBzdHJpbmc7IHJ1bl9pZDogc3RyaW5nOyB0aWNrOiBudW1iZXIgfSkgPT4ge1xuICAgICAgICBzZXRMb2NhbFJ1bklkKHBheWxvYWQucnVuX2lkKTtcbiAgICAgIH0sXG4gICAgICBvblJ1bkVuZDogKCkgPT4ge1xuICAgICAgICAvLyBSZXNldCBsb2NhbCBydW4gc28gY2FtZXJhIHNuYXBzIGJhY2sgdG8gc3RhcnQgYW5kIGRvZXNuJ3QgZm9sbG93IG90aGVyc1xuICAgICAgICBzZXRMb2NhbFJ1bklkKG51bGwpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBvbktleSA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICBpZiAoZS5jb2RlID09PSBcIlNwYWNlXCIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJmbGFwXCIpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleSk7XG4gICAgY29uc3Qgb25UYXAgPSAoKSA9PiB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJmbGFwXCIpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uVGFwKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5KTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25UYXApO1xuICAgICAgY2xlYW51cD8uKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIERlcml2ZSB0aGUgbG9jYWwgcGxheWVyIGVudGl0eSBmb3IgdGhlIGFjdGl2ZSBydW4gaWYga25vd24gKGJ5IHJ1bl9pZClcbiAgY29uc3QgbG9jYWxQbGF5ZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWxvY2FsUnVuSWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHBsYXllcnMuZmluZCgocCkgPT4gcC5ydW5faWQgPT09IGxvY2FsUnVuSWQpO1xuICB9LCBbcGxheWVycywgbG9jYWxSdW5JZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IHJhZiA9IDA7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcbiAgICBjb25zdCBkcHIgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKTtcbiAgICAvLyBSZXNpemUgYmFja2luZyBzdG9yZSBmb3IgY3Jpc3AgcmVuZGVyaW5nXG4gICAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIGRwcik7XG4gICAgY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0ICogZHByKTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xuICAgIGNvbnN0IHJlbmRlciA9ICgpID0+IHtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAvLyBCYWNrZ3JvdW5kXG4gICAgICBjdHguZmlsbFN0eWxlID0gXCIjMGUxNTIwXCI7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIFdvcmxkIHNjYWxpbmcgdG8gbWF0Y2ggc2VydmVyLXNpZGUgV09STERfSEVJR0hUXG4gICAgICBjb25zdCBXT1JMRF9IID0gNjAwO1xuICAgICAgY29uc3Qgc1kgPSBoZWlnaHQgLyBXT1JMRF9IO1xuICAgICAgLy8gQ2FtZXJhOiBhbmNob3Igb25seSB0byBsb2NhbCBwbGF5ZXIncyBkaXN0YW5jZTsgb3RoZXJ3aXNlIHN0YXkgYXQgb3JpZ2luIChkb24ndCBmb2xsb3cgb3RoZXJzKVxuICBjb25zdCBMRUFEX0lOID0gMTYwOyAvLyBwaXhlbHMgb2Ygc3BhY2UgYWhlYWQgb2YgcGxheWVyIG9uIHRoZSBsZWZ0IHNpZGVcbiAgICAgIGNvbnN0IGNhbVggPSBsb2NhbFBsYXllciA/IGxvY2FsUGxheWVyLmRpc3RhbmNlIDogMDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IHBpcGVzIHRvIHJlbmRlciBzbyB0aGV5IGZpbGwgdGhlIHNjcmVlbiB3aWR0aFxuICAgICAgY29uc3Qgc3BhY2luZ1B4ID0gZ2V0UGlwZVNwYWNpbmdQeCgpO1xuICBjb25zdCBjb3VudEFmdGVyID0gTWF0aC5jZWlsKCh3aWR0aCArIExFQURfSU4pIC8gc3BhY2luZ1B4KSArIDI7XG4gIGNvbnN0IGNvdW50QmVmb3JlID0gMzsgLy8gYSBiaXQgbW9yZSBoaXN0b3J5IHNvIHBpcGVzIGRvbid0IGRyb3AgdG9vIGVhcmx5XG5cbiAgICAgIGlmIChzZWVkKSB7XG4gICAgICAgIGNvbnN0IHBpcGVzID0gZ2V0UGlwZXNBdFRpY2soc2VlZCwgdGljaywgeyB3b3JsZEhlaWdodDogV09STERfSCwgY291bnRCZWZvcmUsIGNvdW50QWZ0ZXIsIGJhc2VEaXN0YW5jZTogY2FtWCB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBpcGVzKSB7XG4gICAgICAgICAgY29uc3Qgc2NyZWVuWCA9IE1hdGgucm91bmQoTEVBRF9JTiArIChwLnggLSBjYW1YKSk7XG4gICAgICAgICAgLy8gQ3VsbCBpZiBjb21wbGV0ZWx5IG9mZiBzY3JlZW4gKG5vbi1zdHJpY3QgdG8gYXZvaWQgZWFybHkgcG9wKVxuICAgICAgICAgIGlmIChzY3JlZW5YICsgcC53aWR0aCA8PSAwIHx8IHNjcmVlblggPj0gd2lkdGgpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHRvcEggPSAocC5nYXBDZW50ZXJZIC0gcC5nYXBIZWlnaHQgLyAyKSAqIHNZO1xuICAgICAgICAgIGNvbnN0IGJvdFkgPSAocC5nYXBDZW50ZXJZICsgcC5nYXBIZWlnaHQgLyAyKSAqIHNZO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMyMmM1NWVcIjtcbiAgICAgICAgICBjdHguZmlsbFJlY3Qoc2NyZWVuWCwgMCwgcC53aWR0aCwgdG9wSCk7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHNjcmVlblgsIGJvdFksIHAud2lkdGgsIGhlaWdodCAtIGJvdFkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXcgcGxheWVycyByZWxhdGl2ZSB0byBjYW1lcmFcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICBjb25zdCBsYWJlbFB4ID0gTWF0aC5tYXgoMTAsIE1hdGgucm91bmQoMTIgKiAoaGVpZ2h0IC8gNjAwKSkpO1xuICAgICAgY3R4LmZvbnQgPSBgJHtsYWJlbFB4fXB4IHN5c3RlbS11aWA7XG4gICAgICBmb3IgKGNvbnN0IHBsIG9mIHBsYXllcnMpIHtcbiAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoTEVBRF9JTiArIChwbC5kaXN0YW5jZSAtIGNhbVgpKTtcbiAgICAgICAgY29uc3QgeSA9IHBsLnBvc2l0aW9uLnkgKiAoaGVpZ2h0IC8gNjAwKTtcbiAgICAgICAgLy8gQXZhdGFyXG4gICAgICAgIGNvbnN0IGlzTG9jYWwgPSBsb2NhbFBsYXllciAmJiBwbC5ydW5faWQgPT09IGxvY2FsUGxheWVyLnJ1bl9pZDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGlzTG9jYWwgPyBcIiNmYmJmMjRcIiA6IFwiIzYwYTVmYVwiO1xuICAgICAgICBjb25zdCBhdyA9IE1hdGgubWF4KDE2LCBNYXRoLnJvdW5kKDI0ICogKGhlaWdodCAvIDYwMCkpKTtcbiAgICAgICAgY29uc3QgYWggPSBNYXRoLm1heCgxMiwgTWF0aC5yb3VuZCgxOCAqIChoZWlnaHQgLyA2MDApKSk7XG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCBhdywgYWgpO1xuICAgICAgICAvLyBMYWJlbCBhYm92ZSBhdmF0YXJcbiAgICAgICAgY29uc3QgbGFiZWwgPSAocGwucGxheWVyX2lkIHx8IFwiP1wiKS5zbGljZSgwLCA2KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2U1ZTdlYlwiO1xuICAgICAgICBjdHguZmlsbFRleHQobGFiZWwsIHggKyBNYXRoLnJvdW5kKGF3IC8gMiksIHkgLSA0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgeWV0IGhhdmUgYSBsb2NhbCBwbGF5ZXIgZnJvbSBzbmFwc2hvdHMsIHJlbmRlciBhIHBsYWNlaG9sZGVyXG4gICAgICBpZiAoIWxvY2FsUGxheWVyKSB7XG4gICAgICAgIGNvbnN0IGF3ID0gTWF0aC5tYXgoMTYsIE1hdGgucm91bmQoMjQgKiAoaGVpZ2h0IC8gNjAwKSkpO1xuICAgICAgICBjb25zdCBhaCA9IE1hdGgubWF4KDEyLCBNYXRoLnJvdW5kKDE4ICogKGhlaWdodCAvIDYwMCkpKTtcbiAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoTEVBRF9JTik7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKChXT1JMRF9IICogMC40KSAqIHNZKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiI2ZiYmYyNFwiOyAvLyBoaWdobGlnaHQgY29sb3IgZm9yIGxvY2FsIHBsYWNlaG9sZGVyXG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCBhdywgYWgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjZTVlN2ViXCI7XG4gICAgICAgIGN0eC5maWxsVGV4dChcIllvdVwiLCB4ICsgTWF0aC5yb3VuZChhdyAvIDIpLCB5IC0gNCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhVRCAocmVuZGVyIGxhc3QgdG8gZW5zdXJlIGl0J3Mgb24gdG9wKVxuICAgICAgY29uc3Qgc3RhdHVzID0gY29ubmVjdGVkID8gXCJDb25uZWN0ZWRcIiA6IFwiQ29ubmVjdGluZy4uLlwiO1xuICAgICAgY29uc3QgaHVkTGluZXM6IHN0cmluZ1tdID0gW3N0YXR1c107XG4gICAgICBjb25zdCBtZSA9IGxvY2FsUGxheWVyO1xuICAgICAgaWYgKG1lKSB7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKG1lLmRpc3RhbmNlKSk7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gbWUuc2NvcmUgPz8gMDtcbiAgICAgICAgaHVkTGluZXMucHVzaChgU2NvcmU6ICR7c2NvcmV9YCk7XG4gICAgICAgIGh1ZExpbmVzLnB1c2goYERpc3Q6ICR7ZGlzdH1weGApO1xuICAgICAgfVxuICAgICAgY29uc3QgbGluZUggPSAxODtcbiAgICAgIGNvbnN0IHBhZCA9IDg7XG4gICAgICBjb25zdCBodWRXID0gMTYwO1xuICAgICAgY29uc3QgaHVkSCA9IGh1ZExpbmVzLmxlbmd0aCAqIGxpbmVIICsgcGFkICogMiAtIDQ7XG4gICAgICAvLyBiYWNrZHJvcCBmb3IgcmVhZGFiaWxpdHlcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMiw2LDIzLDAuNilcIjtcbiAgICAgIGN0eC5maWxsUmVjdCg4LCA4LCBodWRXLCBodWRIKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNjYmQ1ZTFcIjtcbiAgICAgIGN0eC5mb250ID0gXCIxNHB4IHN5c3RlbS11aVwiO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG4gICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICBsZXQgeU9mZiA9IDggKyBwYWQgLSAyO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGh1ZExpbmVzKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChsaW5lLCAxMiwgeU9mZik7XG4gICAgICAgIHlPZmYgKz0gbGluZUg7XG4gICAgICB9XG5cbiAgICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXIpO1xuICAgIH07XG4gICAgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG4gICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gIH0sIFt3aWR0aCwgaGVpZ2h0LCBzZWVkLCB0aWNrLCBwbGF5ZXJzLCBjb25uZWN0ZWQsIGxvY2FsUnVuSWRdKTtcblxuICByZXR1cm4gPGNhbnZhcyByZWY9e2NhbnZhc1JlZn0gd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gLz47XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwiZ2V0UGlwZXNBdFRpY2siLCJnZXRQaXBlU3BhY2luZ1B4IiwiY29ubmVjdCIsIkdhbWVDYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsImNhbnZhc1JlZiIsImNvbm5lY3RlZCIsInNldENvbm5lY3RlZCIsInNlZWQiLCJzZXRTZWVkIiwidGljayIsInNldFRpY2siLCJwbGF5ZXJzIiwic2V0UGxheWVycyIsImxvY2FsUnVuSWQiLCJzZXRMb2NhbFJ1bklkIiwiY2xlYW51cCIsIm9uT3BlbiIsIm9uQ2xvc2UiLCJvbkpvaW5BY2siLCJwYXlsb2FkIiwib25TbmFwc2hvdCIsIm9uUnVuU3RhcnQiLCJydW5faWQiLCJvblJ1bkVuZCIsIm9uS2V5IiwiZSIsImNvZGUiLCJwcmV2ZW50RGVmYXVsdCIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblRhcCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsb2NhbFBsYXllciIsInVuZGVmaW5lZCIsImZpbmQiLCJwIiwicmFmIiwiY2FudmFzIiwiY3VycmVudCIsImRwciIsIk1hdGgiLCJtYXgiLCJmbG9vciIsImRldmljZVBpeGVsUmF0aW8iLCJzdHlsZSIsImN0eCIsImdldENvbnRleHQiLCJzZXRUcmFuc2Zvcm0iLCJyZW5kZXIiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsIldPUkxEX0giLCJzWSIsIkxFQURfSU4iLCJjYW1YIiwiZGlzdGFuY2UiLCJzcGFjaW5nUHgiLCJjb3VudEFmdGVyIiwiY2VpbCIsImNvdW50QmVmb3JlIiwicGlwZXMiLCJ3b3JsZEhlaWdodCIsImJhc2VEaXN0YW5jZSIsInNjcmVlblgiLCJyb3VuZCIsIngiLCJ0b3BIIiwiZ2FwQ2VudGVyWSIsImdhcEhlaWdodCIsImJvdFkiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJsYWJlbFB4IiwiZm9udCIsInBsIiwieSIsInBvc2l0aW9uIiwiaXNMb2NhbCIsImF3IiwiYWgiLCJsYWJlbCIsInBsYXllcl9pZCIsInNsaWNlIiwiZmlsbFRleHQiLCJzdGF0dXMiLCJodWRMaW5lcyIsIm1lIiwiZGlzdCIsInNjb3JlIiwicHVzaCIsImxpbmVIIiwicGFkIiwiaHVkVyIsImh1ZEgiLCJsZW5ndGgiLCJ5T2ZmIiwibGluZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/GameCanvas.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/net.ts":
/*!********************!*\
  !*** ./lib/net.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connect: function() { return /* binding */ connect; }\n/* harmony export */ });\n// Minimal WebSocket client that follows the protocol envelope.\nfunction connect(h) {\n    // In dev, server runs on ws://localhost:3000 per quickstart; override via NEXT_PUBLIC_WS_URL\n    const url = \"ws://localhost:3001\" || 0;\n    const ws = new WebSocket(url);\n    const send = (obj)=>ws.readyState === ws.OPEN && ws.send(JSON.stringify(obj));\n    ws.addEventListener(\"open\", ()=>{\n        var _h_onOpen;\n        (_h_onOpen = h.onOpen) === null || _h_onOpen === void 0 ? void 0 : _h_onOpen.call(h);\n        // Join immediately\n        send({\n            protocol_version: \"1\",\n            type: \"join.request\",\n            payload: {}\n        });\n    });\n    ws.addEventListener(\"close\", ()=>{\n        var _h_onClose;\n        return (_h_onClose = h.onClose) === null || _h_onClose === void 0 ? void 0 : _h_onClose.call(h);\n    });\n    ws.addEventListener(\"message\", (ev)=>{\n        try {\n            var _h_onJoinAck, _h_onSnapshot, _h_onRunStart, _h_onRunEnd;\n            const msg = JSON.parse(ev.data.toString());\n            const type = msg === null || msg === void 0 ? void 0 : msg.type;\n            const payload = msg === null || msg === void 0 ? void 0 : msg.payload;\n            if (type === \"join.ack\") (_h_onJoinAck = h.onJoinAck) === null || _h_onJoinAck === void 0 ? void 0 : _h_onJoinAck.call(h, payload);\n            else if (type === \"snapshot.event\") (_h_onSnapshot = h.onSnapshot) === null || _h_onSnapshot === void 0 ? void 0 : _h_onSnapshot.call(h, payload);\n            else if (type === \"runStart.event\") (_h_onRunStart = h.onRunStart) === null || _h_onRunStart === void 0 ? void 0 : _h_onRunStart.call(h, payload);\n            else if (type === \"runEnd.event\") (_h_onRunEnd = h.onRunEnd) === null || _h_onRunEnd === void 0 ? void 0 : _h_onRunEnd.call(h, payload);\n        } catch (e) {}\n    });\n    const onFlap = ()=>{\n        send({\n            protocol_version: \"1\",\n            type: \"input.flap.request\",\n            payload: {\n                nonce: Math.random().toString(36).slice(2)\n            }\n        });\n    };\n    window.addEventListener(\"flap\", onFlap);\n    return ()=>{\n        window.removeEventListener(\"flap\", onFlap);\n        try {\n            ws.close();\n        } catch (e) {}\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9uZXQudHMiLCJtYXBwaW5ncyI6Ijs7OztBQVdBLCtEQUErRDtBQUN4RCxTQUFTQSxRQUFRQyxDQUFXO0lBQ2pDLDZGQUE2RjtJQUM3RixNQUFNQyxNQUFNQyxxQkFBOEIsSUFBSSxDQUFxQjtJQUNuRSxNQUFNRyxLQUFLLElBQUlDLFVBQVVMO0lBRXpCLE1BQU1NLE9BQU8sQ0FBQ0MsTUFBYUgsR0FBR0ksVUFBVSxLQUFLSixHQUFHSyxJQUFJLElBQUlMLEdBQUdFLElBQUksQ0FBQ0ksS0FBS0MsU0FBUyxDQUFDSjtJQUUvRUgsR0FBR1EsZ0JBQWdCLENBQUMsUUFBUTtZQUMxQmI7U0FBQUEsWUFBQUEsRUFBRWMsTUFBTSxjQUFSZCxnQ0FBQUEsZUFBQUE7UUFDQSxtQkFBbUI7UUFDbkJPLEtBQUs7WUFBRVEsa0JBQWtCO1lBQUtDLE1BQU07WUFBZ0JDLFNBQVMsQ0FBQztRQUFFO0lBQ2xFO0lBQ0FaLEdBQUdRLGdCQUFnQixDQUFDLFNBQVM7WUFBTWI7Z0JBQUFBLGFBQUFBLEVBQUVrQixPQUFPLGNBQVRsQixpQ0FBQUEsZ0JBQUFBOztJQUNuQ0ssR0FBR1EsZ0JBQWdCLENBQUMsV0FBVyxDQUFDTTtRQUM5QixJQUFJO2dCQUl1Qm5CLGNBQ1dBLGVBQ0FBLGVBQ0ZBO1lBTmxDLE1BQU1vQixNQUFNVCxLQUFLVSxLQUFLLENBQUNGLEdBQUdHLElBQUksQ0FBQ0MsUUFBUTtZQUN2QyxNQUFNUCxPQUFPSSxnQkFBQUEsMEJBQUFBLElBQUtKLElBQUk7WUFDdEIsTUFBTUMsVUFBVUcsZ0JBQUFBLDBCQUFBQSxJQUFLSCxPQUFPO1lBQzVCLElBQUlELFNBQVMsYUFBWWhCLGVBQUFBLEVBQUV3QixTQUFTLGNBQVh4QixtQ0FBQUEsa0JBQUFBLEdBQWNpQjtpQkFDbEMsSUFBSUQsU0FBUyxtQkFBa0JoQixnQkFBQUEsRUFBRXlCLFVBQVUsY0FBWnpCLG9DQUFBQSxtQkFBQUEsR0FBZWlCO2lCQUM5QyxJQUFJRCxTQUFTLG1CQUFrQmhCLGdCQUFBQSxFQUFFMEIsVUFBVSxjQUFaMUIsb0NBQUFBLG1CQUFBQSxHQUFlaUI7aUJBQzlDLElBQUlELFNBQVMsaUJBQWdCaEIsY0FBQUEsRUFBRTJCLFFBQVEsY0FBVjNCLGtDQUFBQSxpQkFBQUEsR0FBYWlCO1FBQ2pELEVBQUUsVUFBTSxDQUFDO0lBQ1g7SUFFQSxNQUFNVyxTQUFTO1FBQ2JyQixLQUFLO1lBQUVRLGtCQUFrQjtZQUFLQyxNQUFNO1lBQXNCQyxTQUFTO2dCQUFFWSxPQUFPQyxLQUFLQyxNQUFNLEdBQUdSLFFBQVEsQ0FBQyxJQUFJUyxLQUFLLENBQUM7WUFBRztRQUFFO0lBQ3BIO0lBQ0FDLE9BQU9wQixnQkFBZ0IsQ0FBQyxRQUFRZTtJQUVoQyxPQUFPO1FBQ0xLLE9BQU9DLG1CQUFtQixDQUFDLFFBQVFOO1FBQ25DLElBQUk7WUFBRXZCLEdBQUc4QixLQUFLO1FBQUksRUFBRSxVQUFNLENBQUM7SUFDN0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbmV0LnRzPzZhYjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBTbmFwc2hvdFBheWxvYWQgfSBmcm9tIFwiLi4vLi4vc2hhcmVkL3R5cGVzXCI7XG5cbmludGVyZmFjZSBIYW5kbGVycyB7XG4gIG9uT3Blbj86ICgpID0+IHZvaWQ7XG4gIG9uQ2xvc2U/OiAoKSA9PiB2b2lkO1xuICBvbkpvaW5BY2s/OiAocGF5bG9hZDogeyByb29tX2lkOiBzdHJpbmc7IHNlZWQ6IHN0cmluZyB9KSA9PiB2b2lkO1xuICBvblNuYXBzaG90PzogKHBheWxvYWQ6IFNuYXBzaG90UGF5bG9hZCkgPT4gdm9pZDtcbiAgb25SdW5TdGFydD86IChwYXlsb2FkOiB7IHJvb21faWQ6IHN0cmluZzsgcnVuX2lkOiBzdHJpbmc7IHRpY2s6IG51bWJlciB9KSA9PiB2b2lkO1xuICBvblJ1bkVuZD86IChwYXlsb2FkOiB7IHJvb21faWQ6IHN0cmluZzsgcnVuX2lkOiBzdHJpbmc7IGZpbmFsX2Rpc3RhbmNlOiBudW1iZXI7IGZpbmFsX3Njb3JlOiBudW1iZXI7IHJlYXNvbjogc3RyaW5nIH0pID0+IHZvaWQ7XG59XG5cbi8vIE1pbmltYWwgV2ViU29ja2V0IGNsaWVudCB0aGF0IGZvbGxvd3MgdGhlIHByb3RvY29sIGVudmVsb3BlLlxuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3QoaDogSGFuZGxlcnMpIHtcbiAgLy8gSW4gZGV2LCBzZXJ2ZXIgcnVucyBvbiB3czovL2xvY2FsaG9zdDozMDAwIHBlciBxdWlja3N0YXJ0OyBvdmVycmlkZSB2aWEgTkVYVF9QVUJMSUNfV1NfVVJMXG4gIGNvbnN0IHVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1dTX1VSTCB8fCBcIndzOi8vbG9jYWxob3N0OjMwMDBcIjtcbiAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KHVybCk7XG5cbiAgY29uc3Qgc2VuZCA9IChvYmo6IGFueSkgPT4gd3MucmVhZHlTdGF0ZSA9PT0gd3MuT1BFTiAmJiB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuXG4gIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsICgpID0+IHtcbiAgICBoLm9uT3Blbj8uKCk7XG4gICAgLy8gSm9pbiBpbW1lZGlhdGVseVxuICAgIHNlbmQoeyBwcm90b2NvbF92ZXJzaW9uOiBcIjFcIiwgdHlwZTogXCJqb2luLnJlcXVlc3RcIiwgcGF5bG9hZDoge30gfSk7XG4gIH0pO1xuICB3cy5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKCkgPT4gaC5vbkNsb3NlPy4oKSk7XG4gIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGV2LmRhdGEudG9TdHJpbmcoKSk7XG4gICAgICBjb25zdCB0eXBlID0gbXNnPy50eXBlO1xuICAgICAgY29uc3QgcGF5bG9hZCA9IG1zZz8ucGF5bG9hZDtcbiAgICAgIGlmICh0eXBlID09PSBcImpvaW4uYWNrXCIpIGgub25Kb2luQWNrPy4ocGF5bG9hZCk7XG4gICAgICBlbHNlIGlmICh0eXBlID09PSBcInNuYXBzaG90LmV2ZW50XCIpIGgub25TbmFwc2hvdD8uKHBheWxvYWQpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJydW5TdGFydC5ldmVudFwiKSBoLm9uUnVuU3RhcnQ/LihwYXlsb2FkKTtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwicnVuRW5kLmV2ZW50XCIpIGgub25SdW5FbmQ/LihwYXlsb2FkKTtcbiAgICB9IGNhdGNoIHt9XG4gIH0pO1xuXG4gIGNvbnN0IG9uRmxhcCA9ICgpID0+IHtcbiAgICBzZW5kKHsgcHJvdG9jb2xfdmVyc2lvbjogXCIxXCIsIHR5cGU6IFwiaW5wdXQuZmxhcC5yZXF1ZXN0XCIsIHBheWxvYWQ6IHsgbm9uY2U6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpIH0gfSk7XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZmxhcFwiLCBvbkZsYXAgYXMgYW55KTtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZmxhcFwiLCBvbkZsYXAgYXMgYW55KTtcbiAgICB0cnkgeyB3cy5jbG9zZSgpOyB9IGNhdGNoIHt9XG4gIH07XG59XG4iXSwibmFtZXMiOlsiY29ubmVjdCIsImgiLCJ1cmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfV1NfVVJMIiwid3MiLCJXZWJTb2NrZXQiLCJzZW5kIiwib2JqIiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJKU09OIiwic3RyaW5naWZ5IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uT3BlbiIsInByb3RvY29sX3ZlcnNpb24iLCJ0eXBlIiwicGF5bG9hZCIsIm9uQ2xvc2UiLCJldiIsIm1zZyIsInBhcnNlIiwiZGF0YSIsInRvU3RyaW5nIiwib25Kb2luQWNrIiwib25TbmFwc2hvdCIsIm9uUnVuU3RhcnQiLCJvblJ1bkVuZCIsIm9uRmxhcCIsIm5vbmNlIiwiTWF0aCIsInJhbmRvbSIsInNsaWNlIiwid2luZG93IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/net.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/track.ts":
/*!**********************!*\
  !*** ./lib/track.ts ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPipeSpacingPx: function() { return /* reexport safe */ _shared_track__WEBPACK_IMPORTED_MODULE_0__.getPipeSpacingPx; },\n/* harmony export */   getPipesAtTick: function() { return /* reexport safe */ _shared_track__WEBPACK_IMPORTED_MODULE_0__.getPipesAtTick; }\n/* harmony export */ });\n/* harmony import */ var _shared_track__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/track */ \"(app-pages-browser)/../shared/track.ts\");\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi90cmFjay50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3RyYWNrLnRzP2JhNWEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZ2V0UGlwZXNBdFRpY2ssIGdldFBpcGVTcGFjaW5nUHggfSBmcm9tIFwiLi4vLi4vc2hhcmVkL3RyYWNrXCI7XG4iXSwibmFtZXMiOlsiZ2V0UGlwZXNBdFRpY2siLCJnZXRQaXBlU3BhY2luZ1B4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/track.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/constants.ts":
/*!******************************!*\
  !*** ../shared/constants.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsConstants: function() { return /* binding */ PhysicsConstants; },\n/* harmony export */   RoomConfig: function() { return /* binding */ RoomConfig; },\n/* harmony export */   TrackConfig: function() { return /* binding */ TrackConfig; }\n/* harmony export */ });\n// Physics and gameplay constants.\n//\n// Notes on determinism and tests:\n// - Values here are intentionally tuned to satisfy the physics, collision, and\n//   snapshot cadence tests in this feature. Changing them may break tests and\n//   client/server parity property checks.\n// - Snapshot cadence is implemented via timers in the Room (server) at ~22ms\n//   (~45 Hz). RoomConfig.snapshotHz is a documentation hint, not a source of\n//   truth for timers.\nconst PhysicsConstants = {\n    gravity: 620,\n    flapImpulse: -180,\n    forwardVelocity: 140,\n    hitbox: {\n        width: 24,\n        height: 18\n    }\n};\nconst TrackConfig = {\n    gapInitialRatio: 0.45,\n    gapTightenPer10s: 0.01,\n    gapMinRatio: 0.3,\n    // Horizontal spacing between pipe columns as seconds of forward travel.\n    // This is multiplied by forwardVelocity to get actual pixels-per-column.\n    // Keep in sync with tests and the client’s track reconstruction logic.\n    spacingSeconds: 3.4,\n    // Extra initial horizontal space before the first pipe appears (in px)\n    initialOffsetPx: 75\n};\nconst RoomConfig = {\n    capacity: 32,\n    physicsHz: 60,\n    // Informational only: server uses a ~22ms interval for snapshots (~45 Hz).\n    snapshotHz: 45\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvY29uc3RhbnRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtDQUFrQztBQUNsQyxFQUFFO0FBQ0Ysa0NBQWtDO0FBQ2xDLCtFQUErRTtBQUMvRSw4RUFBOEU7QUFDOUUsMENBQTBDO0FBQzFDLDZFQUE2RTtBQUM3RSw2RUFBNkU7QUFDN0Usc0JBQXNCO0FBQ2YsTUFBTUEsbUJBQW1CO0lBQzlCQyxTQUFTO0lBQ1RDLGFBQWEsQ0FBQztJQUNkQyxpQkFBaUI7SUFDakJDLFFBQVE7UUFBRUMsT0FBTztRQUFJQyxRQUFRO0lBQUc7QUFDbEMsRUFBVztBQUVKLE1BQU1DLGNBQWM7SUFDekJDLGlCQUFpQjtJQUNqQkMsa0JBQWtCO0lBQ2xCQyxhQUFhO0lBQ2Isd0VBQXdFO0lBQ3hFLHlFQUF5RTtJQUN6RSx1RUFBdUU7SUFDdkVDLGdCQUFnQjtJQUNoQix1RUFBdUU7SUFDdkVDLGlCQUFpQjtBQUNuQixFQUFXO0FBRUosTUFBTUMsYUFBYTtJQUN4QkMsVUFBVTtJQUNWQyxXQUFXO0lBQ1gsMkVBQTJFO0lBQzNFQyxZQUFZO0FBQ2QsRUFBVyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vc2hhcmVkL2NvbnN0YW50cy50cz8yNzJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBoeXNpY3MgYW5kIGdhbWVwbGF5IGNvbnN0YW50cy5cbi8vXG4vLyBOb3RlcyBvbiBkZXRlcm1pbmlzbSBhbmQgdGVzdHM6XG4vLyAtIFZhbHVlcyBoZXJlIGFyZSBpbnRlbnRpb25hbGx5IHR1bmVkIHRvIHNhdGlzZnkgdGhlIHBoeXNpY3MsIGNvbGxpc2lvbiwgYW5kXG4vLyAgIHNuYXBzaG90IGNhZGVuY2UgdGVzdHMgaW4gdGhpcyBmZWF0dXJlLiBDaGFuZ2luZyB0aGVtIG1heSBicmVhayB0ZXN0cyBhbmRcbi8vICAgY2xpZW50L3NlcnZlciBwYXJpdHkgcHJvcGVydHkgY2hlY2tzLlxuLy8gLSBTbmFwc2hvdCBjYWRlbmNlIGlzIGltcGxlbWVudGVkIHZpYSB0aW1lcnMgaW4gdGhlIFJvb20gKHNlcnZlcikgYXQgfjIybXNcbi8vICAgKH40NSBIeikuIFJvb21Db25maWcuc25hcHNob3RIeiBpcyBhIGRvY3VtZW50YXRpb24gaGludCwgbm90IGEgc291cmNlIG9mXG4vLyAgIHRydXRoIGZvciB0aW1lcnMuXG5leHBvcnQgY29uc3QgUGh5c2ljc0NvbnN0YW50cyA9IHtcbiAgZ3Jhdml0eTogNjIwLCAvLyBweC9zXjJcbiAgZmxhcEltcHVsc2U6IC0xODAsIC8vIHB4L3MgYXBwbGllZCB0byB2eVxuICBmb3J3YXJkVmVsb2NpdHk6IDE0MCwgLy8gcHgvcyBhbG9uZyB4IGZvciBkaXN0YW5jZSBjb21wdXRhdGlvblxuICBoaXRib3g6IHsgd2lkdGg6IDI0LCBoZWlnaHQ6IDE4IH0sXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgVHJhY2tDb25maWcgPSB7XG4gIGdhcEluaXRpYWxSYXRpbzogMC40NSxcbiAgZ2FwVGlnaHRlblBlcjEwczogMC4wMSxcbiAgZ2FwTWluUmF0aW86IDAuMyxcbiAgLy8gSG9yaXpvbnRhbCBzcGFjaW5nIGJldHdlZW4gcGlwZSBjb2x1bW5zIGFzIHNlY29uZHMgb2YgZm9yd2FyZCB0cmF2ZWwuXG4gIC8vIFRoaXMgaXMgbXVsdGlwbGllZCBieSBmb3J3YXJkVmVsb2NpdHkgdG8gZ2V0IGFjdHVhbCBwaXhlbHMtcGVyLWNvbHVtbi5cbiAgLy8gS2VlcCBpbiBzeW5jIHdpdGggdGVzdHMgYW5kIHRoZSBjbGllbnTigJlzIHRyYWNrIHJlY29uc3RydWN0aW9uIGxvZ2ljLlxuICBzcGFjaW5nU2Vjb25kczogMy40LFxuICAvLyBFeHRyYSBpbml0aWFsIGhvcml6b250YWwgc3BhY2UgYmVmb3JlIHRoZSBmaXJzdCBwaXBlIGFwcGVhcnMgKGluIHB4KVxuICBpbml0aWFsT2Zmc2V0UHg6IDc1LFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFJvb21Db25maWcgPSB7XG4gIGNhcGFjaXR5OiAzMixcbiAgcGh5c2ljc0h6OiA2MCxcbiAgLy8gSW5mb3JtYXRpb25hbCBvbmx5OiBzZXJ2ZXIgdXNlcyBhIH4yMm1zIGludGVydmFsIGZvciBzbmFwc2hvdHMgKH40NSBIeikuXG4gIHNuYXBzaG90SHo6IDQ1LFxufSBhcyBjb25zdDtcbiJdLCJuYW1lcyI6WyJQaHlzaWNzQ29uc3RhbnRzIiwiZ3Jhdml0eSIsImZsYXBJbXB1bHNlIiwiZm9yd2FyZFZlbG9jaXR5IiwiaGl0Ym94Iiwid2lkdGgiLCJoZWlnaHQiLCJUcmFja0NvbmZpZyIsImdhcEluaXRpYWxSYXRpbyIsImdhcFRpZ2h0ZW5QZXIxMHMiLCJnYXBNaW5SYXRpbyIsInNwYWNpbmdTZWNvbmRzIiwiaW5pdGlhbE9mZnNldFB4IiwiUm9vbUNvbmZpZyIsImNhcGFjaXR5IiwicGh5c2ljc0h6Iiwic25hcHNob3RIeiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/constants.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/../shared/track.ts":
/*!**************************!*\
  !*** ../shared/track.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPipeSpacingPx: function() { return /* binding */ getPipeSpacingPx; },\n/* harmony export */   getPipesAtTick: function() { return /* binding */ getPipesAtTick; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-pages-browser)/../shared/constants.ts\");\n// NodeNext requires explicit .js extension for relative ESM imports at runtime.\n\nfunction xorshift32(seed) {\n    let x = seed | 0;\n    return ()=>{\n        x ^= x << 13;\n        x ^= x >>> 17;\n        x ^= x << 5;\n        // Convert to [0,1)\n        return (x >>> 0) / 0xffffffff;\n    };\n}\nfunction seedStringToInt(s) {\n    let h = 2166136261;\n    for(let i = 0; i < s.length; i++){\n        h ^= s.charCodeAt(i);\n        h = Math.imul(h, 16777619);\n    }\n    return h >>> 0;\n}\n// Deterministic track generator.\n//\n// Contract:\n// - Input: (seed, tick, opts?) where tick progresses at the server’s physics Hz.\n// - Output: Stable sequence of pipe columns with x positions in world pixels and\n//   gap geometry derived from a seeded PRNG.\n// - Determinism: For a given seed and generation index, the RNG call order and\n//   difficulty progression must be identical on client and server. We derive a\n//   generation index `g` from world index `i` so that changing initial offsets\n//   (runway space before first pipe) does not alter RNG progression.\n// - Difficulty: gap height tightens by TrackConfig.gapTightenPer10s every 10s\n//   of pipe cadence time, clamped at TrackConfig.gapMinRatio.\nfunction getPipesAtTick(seed, tick, opts) {\n    var _opts_worldHeight;\n    const H = (_opts_worldHeight = opts === null || opts === void 0 ? void 0 : opts.worldHeight) !== null && _opts_worldHeight !== void 0 ? _opts_worldHeight : 600;\n    const spacingS = _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.spacingSeconds;\n    const spacingPx = _constants_js__WEBPACK_IMPORTED_MODULE_0__.PhysicsConstants.forwardVelocity * spacingS;\n    const pipeWidth = 52;\n    // Determine how many pipes have been passed given tick and forward velocity\n    const time = tick / 60; // physics Hz for reference\n    const defaultDistance = time * _constants_js__WEBPACK_IMPORTED_MODULE_0__.PhysicsConstants.forwardVelocity;\n    var _opts_baseDistance;\n    const distance = (_opts_baseDistance = opts === null || opts === void 0 ? void 0 : opts.baseDistance) !== null && _opts_baseDistance !== void 0 ? _opts_baseDistance : defaultDistance;\n    // Choose index near the pipe whose left edge is at/just ahead of the player's distance.\n    // World index i defines x position: x(i) = (i + 1) * spacingPx + initialOffsetPx\n    // so i ≈ (distance - initialOffsetPx) / spacingPx - 1.\n    //\n    // IMPORTANT: We decouple the procedural \"generation index\" (g) from the world index (i)\n    // so that adding initialOffsetPx creates empty runway without advancing the RNG sequence\n    // or the difficulty schedule. Concretely, g = i - baseAtZero, where baseAtZero is the\n    // world index computed at distance = 0. This makes g start at 0 near the origin and\n    // progress independently of the initial horizontal offset.\n    const pipeIndexBase = Math.floor((distance - _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.initialOffsetPx) / spacingPx) - 1;\n    const baseAtZero = Math.floor((0 - _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.initialOffsetPx) / spacingPx) - 1; // index when distance = 0\n    // Create RNG seeded by seed + index to get stable per-pipe variations\n    const baseSeed = seedStringToInt(seed);\n    const results = [];\n    var _opts_countBefore;\n    const before = Math.max(0, Math.floor((_opts_countBefore = opts === null || opts === void 0 ? void 0 : opts.countBefore) !== null && _opts_countBefore !== void 0 ? _opts_countBefore : 0));\n    var _opts_countAfter;\n    const after = Math.max(1, Math.floor((_opts_countAfter = opts === null || opts === void 0 ? void 0 : opts.countAfter) !== null && _opts_countAfter !== void 0 ? _opts_countAfter : 3));\n    const start = Math.max(0, pipeIndexBase - before);\n    // Guarantee we produce some pipes even if the base index is negative (pre-runway)\n    const end = Math.max(start + after, pipeIndexBase + after); // exclusive upper bound\n    for(let i = start; i < end; i++){\n        // Use generation index equal to world index so first pipe corresponds to g≈0.\n        // As long as consumers compute `i` consistently from x positions, RNG alignment holds.\n        const g = i; // generation index starts at ~0 for the first real pipe\n        const rng = xorshift32(baseSeed ^ g * 0x9e3779b1);\n        // Gap tightening over time is based on generation index\n        const seconds = Math.max(0, g * spacingS);\n        let gapRatio = _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.gapInitialRatio - _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.gapTightenPer10s * (seconds / 10);\n        gapRatio = Math.max(_constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.gapMinRatio, gapRatio);\n        const gapHeight = H * gapRatio;\n        // Gap center jitter within bounds [gapHeight/2, H - gapHeight/2]\n        const minCenter = gapHeight / 2 + 10;\n        const maxCenter = H - gapHeight / 2 - 10;\n        const gapCenterY = minCenter + (maxCenter - minCenter) * rng();\n        const x = (i + 1) * spacingPx + _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.initialOffsetPx; // ahead of origin with configurable offset\n        results.push({\n            x,\n            gapCenterY,\n            gapHeight,\n            width: pipeWidth\n        });\n    }\n    return results;\n}\n// Helper for consumers to know the horizontal spacing between pipe columns in px\nfunction getPipeSpacingPx() {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.PhysicsConstants.forwardVelocity * _constants_js__WEBPACK_IMPORTED_MODULE_0__.TrackConfig.spacingSeconds;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9zaGFyZWQvdHJhY2sudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0ZBQWdGO0FBQ2pCO0FBUy9ELFNBQVNFLFdBQVdDLElBQVk7SUFDOUIsSUFBSUMsSUFBSUQsT0FBTztJQUNmLE9BQU87UUFDTEMsS0FBS0EsS0FBSztRQUNWQSxLQUFLQSxNQUFNO1FBQ1hBLEtBQUtBLEtBQUs7UUFDVixtQkFBbUI7UUFDbkIsT0FBTyxDQUFDQSxNQUFNLEtBQUs7SUFDckI7QUFDRjtBQUVBLFNBQVNDLGdCQUFnQkMsQ0FBUztJQUNoQyxJQUFJQyxJQUFJO0lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLEVBQUVHLE1BQU0sRUFBRUQsSUFBSztRQUNqQ0QsS0FBS0QsRUFBRUksVUFBVSxDQUFDRjtRQUNsQkQsSUFBSUksS0FBS0MsSUFBSSxDQUFDTCxHQUFHO0lBQ25CO0lBQ0EsT0FBT0EsTUFBTTtBQUNmO0FBRUEsaUNBQWlDO0FBQ2pDLEVBQUU7QUFDRixZQUFZO0FBQ1osaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRiw2Q0FBNkM7QUFDN0MsK0VBQStFO0FBQy9FLCtFQUErRTtBQUMvRSwrRUFBK0U7QUFDL0UscUVBQXFFO0FBQ3JFLDhFQUE4RTtBQUM5RSw4REFBOEQ7QUFDdkQsU0FBU00sZUFDZFYsSUFBWSxFQUNaVyxJQUFZLEVBQ1pDLElBQWlHO1FBRXZGQTtJQUFWLE1BQU1DLElBQUlELENBQUFBLG9CQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1FLFdBQVcsY0FBakJGLCtCQUFBQSxvQkFBcUI7SUFDL0IsTUFBTUcsV0FBV2xCLHNEQUFXQSxDQUFDbUIsY0FBYztJQUMzQyxNQUFNQyxZQUFZbkIsMkRBQWdCQSxDQUFDb0IsZUFBZSxHQUFHSDtJQUNyRCxNQUFNSSxZQUFZO0lBRWxCLDRFQUE0RTtJQUM1RSxNQUFNQyxPQUFPVCxPQUFPLElBQUksMkJBQTJCO0lBQ25ELE1BQU1VLGtCQUFrQkQsT0FBT3RCLDJEQUFnQkEsQ0FBQ29CLGVBQWU7UUFDOUNOO0lBQWpCLE1BQU1VLFdBQVdWLENBQUFBLHFCQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1XLFlBQVksY0FBbEJYLGdDQUFBQSxxQkFBc0JTO0lBQ3ZDLHdGQUF3RjtJQUN4RixpRkFBaUY7SUFDakYsdURBQXVEO0lBQ3ZELEVBQUU7SUFDRix3RkFBd0Y7SUFDeEYseUZBQXlGO0lBQ3pGLHNGQUFzRjtJQUN0RixvRkFBb0Y7SUFDcEYsMkRBQTJEO0lBQzNELE1BQU1HLGdCQUFnQmhCLEtBQUtpQixLQUFLLENBQUMsQ0FBQ0gsV0FBV3pCLHNEQUFXQSxDQUFDNkIsZUFBZSxJQUFJVCxhQUFhO0lBQ3pGLE1BQU1VLGFBQWFuQixLQUFLaUIsS0FBSyxDQUFDLENBQUMsSUFBSTVCLHNEQUFXQSxDQUFDNkIsZUFBZSxJQUFJVCxhQUFhLEdBQUcsMEJBQTBCO0lBRTVHLHNFQUFzRTtJQUN0RSxNQUFNVyxXQUFXMUIsZ0JBQWdCRjtJQUVqQyxNQUFNNkIsVUFBc0IsRUFBRTtRQUNRakI7SUFBdEMsTUFBTWtCLFNBQVN0QixLQUFLdUIsR0FBRyxDQUFDLEdBQUd2QixLQUFLaUIsS0FBSyxDQUFDYixDQUFBQSxvQkFBQUEsaUJBQUFBLDJCQUFBQSxLQUFNb0IsV0FBVyxjQUFqQnBCLCtCQUFBQSxvQkFBcUI7UUFDdEJBO0lBQXJDLE1BQU1xQixRQUFRekIsS0FBS3VCLEdBQUcsQ0FBQyxHQUFHdkIsS0FBS2lCLEtBQUssQ0FBQ2IsQ0FBQUEsbUJBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTXNCLFVBQVUsY0FBaEJ0Qiw4QkFBQUEsbUJBQW9CO0lBQ3pELE1BQU11QixRQUFRM0IsS0FBS3VCLEdBQUcsQ0FBQyxHQUFHUCxnQkFBZ0JNO0lBQzFDLGtGQUFrRjtJQUNsRixNQUFNTSxNQUFNNUIsS0FBS3VCLEdBQUcsQ0FBQ0ksUUFBUUYsT0FBT1QsZ0JBQWdCUyxRQUFRLHdCQUF3QjtJQUNwRixJQUFLLElBQUk1QixJQUFJOEIsT0FBTzlCLElBQUkrQixLQUFLL0IsSUFBSztRQUNoQyw4RUFBOEU7UUFDOUUsdUZBQXVGO1FBQ3ZGLE1BQU1nQyxJQUFJaEMsR0FBRyx3REFBd0Q7UUFDckUsTUFBTWlDLE1BQU12QyxXQUFXNkIsV0FBWVMsSUFBSTtRQUV2Qyx3REFBd0Q7UUFDeEQsTUFBTUUsVUFBVS9CLEtBQUt1QixHQUFHLENBQUMsR0FBR00sSUFBSXRCO1FBQ2hDLElBQUl5QixXQUNGM0Msc0RBQVdBLENBQUM0QyxlQUFlLEdBQzNCNUMsc0RBQVdBLENBQUM2QyxnQkFBZ0IsR0FBSUgsQ0FBQUEsVUFBVSxFQUFDO1FBQzdDQyxXQUFXaEMsS0FBS3VCLEdBQUcsQ0FBQ2xDLHNEQUFXQSxDQUFDOEMsV0FBVyxFQUFFSDtRQUM3QyxNQUFNSSxZQUFZL0IsSUFBSTJCO1FBRXRCLGlFQUFpRTtRQUNqRSxNQUFNSyxZQUFZRCxZQUFZLElBQUk7UUFDbEMsTUFBTUUsWUFBWWpDLElBQUkrQixZQUFZLElBQUk7UUFDdEMsTUFBTUcsYUFBYUYsWUFBWSxDQUFDQyxZQUFZRCxTQUFRLElBQUtQO1FBRXpELE1BQU1yQyxJQUFJLENBQUNJLElBQUksS0FBS1ksWUFBWXBCLHNEQUFXQSxDQUFDNkIsZUFBZSxFQUFFLDJDQUEyQztRQUV4R0csUUFBUW1CLElBQUksQ0FBQztZQUFFL0M7WUFBRzhDO1lBQVlIO1lBQVdLLE9BQU85QjtRQUFVO0lBQzVEO0lBQ0EsT0FBT1U7QUFDVDtBQUVBLGlGQUFpRjtBQUMxRSxTQUFTcUI7SUFDZCxPQUFPcEQsMkRBQWdCQSxDQUFDb0IsZUFBZSxHQUFHckIsc0RBQVdBLENBQUNtQixjQUFjO0FBQ3RFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9zaGFyZWQvdHJhY2sudHM/ZDg5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOb2RlTmV4dCByZXF1aXJlcyBleHBsaWNpdCAuanMgZXh0ZW5zaW9uIGZvciByZWxhdGl2ZSBFU00gaW1wb3J0cyBhdCBydW50aW1lLlxuaW1wb3J0IHsgVHJhY2tDb25maWcsIFBoeXNpY3NDb25zdGFudHMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBQaXBlU3BlYyB7XG4gIHg6IG51bWJlcjsgLy8gbGVmdCB4IG9mIHBpcGUgcGFpclxuICBnYXBDZW50ZXJZOiBudW1iZXI7XG4gIGdhcEhlaWdodDogbnVtYmVyO1xuICB3aWR0aDogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiB4b3JzaGlmdDMyKHNlZWQ6IG51bWJlcikge1xuICBsZXQgeCA9IHNlZWQgfCAwO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHggXj0geCA8PCAxMztcbiAgICB4IF49IHggPj4+IDE3O1xuICAgIHggXj0geCA8PCA1O1xuICAgIC8vIENvbnZlcnQgdG8gWzAsMSlcbiAgICByZXR1cm4gKHggPj4+IDApIC8gMHhmZmZmZmZmZjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VlZFN0cmluZ1RvSW50KHM6IHN0cmluZyk6IG51bWJlciB7XG4gIGxldCBoID0gMjE2NjEzNjI2MTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgaCBePSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaCA9IE1hdGguaW11bChoLCAxNjc3NzYxOSk7XG4gIH1cbiAgcmV0dXJuIGggPj4+IDA7XG59XG5cbi8vIERldGVybWluaXN0aWMgdHJhY2sgZ2VuZXJhdG9yLlxuLy9cbi8vIENvbnRyYWN0OlxuLy8gLSBJbnB1dDogKHNlZWQsIHRpY2ssIG9wdHM/KSB3aGVyZSB0aWNrIHByb2dyZXNzZXMgYXQgdGhlIHNlcnZlcuKAmXMgcGh5c2ljcyBIei5cbi8vIC0gT3V0cHV0OiBTdGFibGUgc2VxdWVuY2Ugb2YgcGlwZSBjb2x1bW5zIHdpdGggeCBwb3NpdGlvbnMgaW4gd29ybGQgcGl4ZWxzIGFuZFxuLy8gICBnYXAgZ2VvbWV0cnkgZGVyaXZlZCBmcm9tIGEgc2VlZGVkIFBSTkcuXG4vLyAtIERldGVybWluaXNtOiBGb3IgYSBnaXZlbiBzZWVkIGFuZCBnZW5lcmF0aW9uIGluZGV4LCB0aGUgUk5HIGNhbGwgb3JkZXIgYW5kXG4vLyAgIGRpZmZpY3VsdHkgcHJvZ3Jlc3Npb24gbXVzdCBiZSBpZGVudGljYWwgb24gY2xpZW50IGFuZCBzZXJ2ZXIuIFdlIGRlcml2ZSBhXG4vLyAgIGdlbmVyYXRpb24gaW5kZXggYGdgIGZyb20gd29ybGQgaW5kZXggYGlgIHNvIHRoYXQgY2hhbmdpbmcgaW5pdGlhbCBvZmZzZXRzXG4vLyAgIChydW53YXkgc3BhY2UgYmVmb3JlIGZpcnN0IHBpcGUpIGRvZXMgbm90IGFsdGVyIFJORyBwcm9ncmVzc2lvbi5cbi8vIC0gRGlmZmljdWx0eTogZ2FwIGhlaWdodCB0aWdodGVucyBieSBUcmFja0NvbmZpZy5nYXBUaWdodGVuUGVyMTBzIGV2ZXJ5IDEwc1xuLy8gICBvZiBwaXBlIGNhZGVuY2UgdGltZSwgY2xhbXBlZCBhdCBUcmFja0NvbmZpZy5nYXBNaW5SYXRpby5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaXBlc0F0VGljayhcbiAgc2VlZDogc3RyaW5nLFxuICB0aWNrOiBudW1iZXIsXG4gIG9wdHM/OiB7IHdvcmxkSGVpZ2h0PzogbnVtYmVyOyBjb3VudEJlZm9yZT86IG51bWJlcjsgY291bnRBZnRlcj86IG51bWJlcjsgYmFzZURpc3RhbmNlPzogbnVtYmVyIH0sXG4pOiBQaXBlU3BlY1tdIHtcbiAgY29uc3QgSCA9IG9wdHM/LndvcmxkSGVpZ2h0ID8/IDYwMDtcbiAgY29uc3Qgc3BhY2luZ1MgPSBUcmFja0NvbmZpZy5zcGFjaW5nU2Vjb25kcztcbiAgY29uc3Qgc3BhY2luZ1B4ID0gUGh5c2ljc0NvbnN0YW50cy5mb3J3YXJkVmVsb2NpdHkgKiBzcGFjaW5nUztcbiAgY29uc3QgcGlwZVdpZHRoID0gNTI7XG5cbiAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IHBpcGVzIGhhdmUgYmVlbiBwYXNzZWQgZ2l2ZW4gdGljayBhbmQgZm9yd2FyZCB2ZWxvY2l0eVxuICBjb25zdCB0aW1lID0gdGljayAvIDYwOyAvLyBwaHlzaWNzIEh6IGZvciByZWZlcmVuY2VcbiAgY29uc3QgZGVmYXVsdERpc3RhbmNlID0gdGltZSAqIFBoeXNpY3NDb25zdGFudHMuZm9yd2FyZFZlbG9jaXR5O1xuICBjb25zdCBkaXN0YW5jZSA9IG9wdHM/LmJhc2VEaXN0YW5jZSA/PyBkZWZhdWx0RGlzdGFuY2U7XG4gIC8vIENob29zZSBpbmRleCBuZWFyIHRoZSBwaXBlIHdob3NlIGxlZnQgZWRnZSBpcyBhdC9qdXN0IGFoZWFkIG9mIHRoZSBwbGF5ZXIncyBkaXN0YW5jZS5cbiAgLy8gV29ybGQgaW5kZXggaSBkZWZpbmVzIHggcG9zaXRpb246IHgoaSkgPSAoaSArIDEpICogc3BhY2luZ1B4ICsgaW5pdGlhbE9mZnNldFB4XG4gIC8vIHNvIGkg4omIIChkaXN0YW5jZSAtIGluaXRpYWxPZmZzZXRQeCkgLyBzcGFjaW5nUHggLSAxLlxuICAvL1xuICAvLyBJTVBPUlRBTlQ6IFdlIGRlY291cGxlIHRoZSBwcm9jZWR1cmFsIFwiZ2VuZXJhdGlvbiBpbmRleFwiIChnKSBmcm9tIHRoZSB3b3JsZCBpbmRleCAoaSlcbiAgLy8gc28gdGhhdCBhZGRpbmcgaW5pdGlhbE9mZnNldFB4IGNyZWF0ZXMgZW1wdHkgcnVud2F5IHdpdGhvdXQgYWR2YW5jaW5nIHRoZSBSTkcgc2VxdWVuY2VcbiAgLy8gb3IgdGhlIGRpZmZpY3VsdHkgc2NoZWR1bGUuIENvbmNyZXRlbHksIGcgPSBpIC0gYmFzZUF0WmVybywgd2hlcmUgYmFzZUF0WmVybyBpcyB0aGVcbiAgLy8gd29ybGQgaW5kZXggY29tcHV0ZWQgYXQgZGlzdGFuY2UgPSAwLiBUaGlzIG1ha2VzIGcgc3RhcnQgYXQgMCBuZWFyIHRoZSBvcmlnaW4gYW5kXG4gIC8vIHByb2dyZXNzIGluZGVwZW5kZW50bHkgb2YgdGhlIGluaXRpYWwgaG9yaXpvbnRhbCBvZmZzZXQuXG4gIGNvbnN0IHBpcGVJbmRleEJhc2UgPSBNYXRoLmZsb29yKChkaXN0YW5jZSAtIFRyYWNrQ29uZmlnLmluaXRpYWxPZmZzZXRQeCkgLyBzcGFjaW5nUHgpIC0gMTtcbiAgY29uc3QgYmFzZUF0WmVybyA9IE1hdGguZmxvb3IoKDAgLSBUcmFja0NvbmZpZy5pbml0aWFsT2Zmc2V0UHgpIC8gc3BhY2luZ1B4KSAtIDE7IC8vIGluZGV4IHdoZW4gZGlzdGFuY2UgPSAwXG5cbiAgLy8gQ3JlYXRlIFJORyBzZWVkZWQgYnkgc2VlZCArIGluZGV4IHRvIGdldCBzdGFibGUgcGVyLXBpcGUgdmFyaWF0aW9uc1xuICBjb25zdCBiYXNlU2VlZCA9IHNlZWRTdHJpbmdUb0ludChzZWVkKTtcblxuICBjb25zdCByZXN1bHRzOiBQaXBlU3BlY1tdID0gW107XG4gIGNvbnN0IGJlZm9yZSA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3Iob3B0cz8uY291bnRCZWZvcmUgPz8gMCkpO1xuICBjb25zdCBhZnRlciA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3Iob3B0cz8uY291bnRBZnRlciA/PyAzKSk7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgcGlwZUluZGV4QmFzZSAtIGJlZm9yZSk7XG4gIC8vIEd1YXJhbnRlZSB3ZSBwcm9kdWNlIHNvbWUgcGlwZXMgZXZlbiBpZiB0aGUgYmFzZSBpbmRleCBpcyBuZWdhdGl2ZSAocHJlLXJ1bndheSlcbiAgY29uc3QgZW5kID0gTWF0aC5tYXgoc3RhcnQgKyBhZnRlciwgcGlwZUluZGV4QmFzZSArIGFmdGVyKTsgLy8gZXhjbHVzaXZlIHVwcGVyIGJvdW5kXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgLy8gVXNlIGdlbmVyYXRpb24gaW5kZXggZXF1YWwgdG8gd29ybGQgaW5kZXggc28gZmlyc3QgcGlwZSBjb3JyZXNwb25kcyB0byBn4omIMC5cbiAgICAvLyBBcyBsb25nIGFzIGNvbnN1bWVycyBjb21wdXRlIGBpYCBjb25zaXN0ZW50bHkgZnJvbSB4IHBvc2l0aW9ucywgUk5HIGFsaWdubWVudCBob2xkcy5cbiAgICBjb25zdCBnID0gaTsgLy8gZ2VuZXJhdGlvbiBpbmRleCBzdGFydHMgYXQgfjAgZm9yIHRoZSBmaXJzdCByZWFsIHBpcGVcbiAgICBjb25zdCBybmcgPSB4b3JzaGlmdDMyKGJhc2VTZWVkIF4gKGcgKiAweDllMzc3OWIxKSk7XG5cbiAgICAvLyBHYXAgdGlnaHRlbmluZyBvdmVyIHRpbWUgaXMgYmFzZWQgb24gZ2VuZXJhdGlvbiBpbmRleFxuICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLm1heCgwLCBnICogc3BhY2luZ1MpO1xuICAgIGxldCBnYXBSYXRpbyA9XG4gICAgICBUcmFja0NvbmZpZy5nYXBJbml0aWFsUmF0aW8gLVxuICAgICAgVHJhY2tDb25maWcuZ2FwVGlnaHRlblBlcjEwcyAqIChzZWNvbmRzIC8gMTApO1xuICAgIGdhcFJhdGlvID0gTWF0aC5tYXgoVHJhY2tDb25maWcuZ2FwTWluUmF0aW8sIGdhcFJhdGlvKTtcbiAgICBjb25zdCBnYXBIZWlnaHQgPSBIICogZ2FwUmF0aW87XG5cbiAgICAvLyBHYXAgY2VudGVyIGppdHRlciB3aXRoaW4gYm91bmRzIFtnYXBIZWlnaHQvMiwgSCAtIGdhcEhlaWdodC8yXVxuICAgIGNvbnN0IG1pbkNlbnRlciA9IGdhcEhlaWdodCAvIDIgKyAxMDtcbiAgICBjb25zdCBtYXhDZW50ZXIgPSBIIC0gZ2FwSGVpZ2h0IC8gMiAtIDEwO1xuICAgIGNvbnN0IGdhcENlbnRlclkgPSBtaW5DZW50ZXIgKyAobWF4Q2VudGVyIC0gbWluQ2VudGVyKSAqIHJuZygpO1xuXG4gICAgY29uc3QgeCA9IChpICsgMSkgKiBzcGFjaW5nUHggKyBUcmFja0NvbmZpZy5pbml0aWFsT2Zmc2V0UHg7IC8vIGFoZWFkIG9mIG9yaWdpbiB3aXRoIGNvbmZpZ3VyYWJsZSBvZmZzZXRcblxuICAgIHJlc3VsdHMucHVzaCh7IHgsIGdhcENlbnRlclksIGdhcEhlaWdodCwgd2lkdGg6IHBpcGVXaWR0aCB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLy8gSGVscGVyIGZvciBjb25zdW1lcnMgdG8ga25vdyB0aGUgaG9yaXpvbnRhbCBzcGFjaW5nIGJldHdlZW4gcGlwZSBjb2x1bW5zIGluIHB4XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGlwZVNwYWNpbmdQeCgpIHtcbiAgcmV0dXJuIFBoeXNpY3NDb25zdGFudHMuZm9yd2FyZFZlbG9jaXR5ICogVHJhY2tDb25maWcuc3BhY2luZ1NlY29uZHM7XG59XG4iXSwibmFtZXMiOlsiVHJhY2tDb25maWciLCJQaHlzaWNzQ29uc3RhbnRzIiwieG9yc2hpZnQzMiIsInNlZWQiLCJ4Iiwic2VlZFN0cmluZ1RvSW50IiwicyIsImgiLCJpIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsIk1hdGgiLCJpbXVsIiwiZ2V0UGlwZXNBdFRpY2siLCJ0aWNrIiwib3B0cyIsIkgiLCJ3b3JsZEhlaWdodCIsInNwYWNpbmdTIiwic3BhY2luZ1NlY29uZHMiLCJzcGFjaW5nUHgiLCJmb3J3YXJkVmVsb2NpdHkiLCJwaXBlV2lkdGgiLCJ0aW1lIiwiZGVmYXVsdERpc3RhbmNlIiwiZGlzdGFuY2UiLCJiYXNlRGlzdGFuY2UiLCJwaXBlSW5kZXhCYXNlIiwiZmxvb3IiLCJpbml0aWFsT2Zmc2V0UHgiLCJiYXNlQXRaZXJvIiwiYmFzZVNlZWQiLCJyZXN1bHRzIiwiYmVmb3JlIiwibWF4IiwiY291bnRCZWZvcmUiLCJhZnRlciIsImNvdW50QWZ0ZXIiLCJzdGFydCIsImVuZCIsImciLCJybmciLCJzZWNvbmRzIiwiZ2FwUmF0aW8iLCJnYXBJbml0aWFsUmF0aW8iLCJnYXBUaWdodGVuUGVyMTBzIiwiZ2FwTWluUmF0aW8iLCJnYXBIZWlnaHQiLCJtaW5DZW50ZXIiLCJtYXhDZW50ZXIiLCJnYXBDZW50ZXJZIiwicHVzaCIsIndpZHRoIiwiZ2V0UGlwZVNwYWNpbmdQeCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../shared/track.ts\n"));

/***/ })

}]);